diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/autotests/CMakeLists.txt kwin-lowlatency/autotests/CMakeLists.txt
--- kwin-5.16.2/autotests/CMakeLists.txt	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/autotests/CMakeLists.txt	2019-06-25 23:16:16.632094321 +0300
@@ -170,6 +170,7 @@
 qt5_add_dbus_adaptor( testScriptedEffectLoader_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/../org.kde.kwin.OrientationSensor.xml ${CMAKE_CURRENT_SOURCE_DIR}/../orientation_sensor.h KWin::OrientationSensor)
 add_executable( testScriptedEffectLoader ${testScriptedEffectLoader_SRCS})
 
+target_compile_definitions(testScriptedEffectLoader PUBLIC KWINLL_NO_OPTIONS)
 target_link_libraries(testScriptedEffectLoader
     Qt5::Concurrent
     Qt5::Qml
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/client.cpp kwin-lowlatency/client.cpp
--- kwin-5.16.2/client.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/client.cpp	2019-06-25 23:16:16.645094300 +0300
@@ -975,6 +975,9 @@
         m_decoInputExtent.map();
         updateHiddenPreview();
     }
+    if (Compositor::isCreated()) {
+        Compositor::self()->checkUnredirect();
+    }
     emit windowShown(this);
 }
 
@@ -990,6 +993,9 @@
         updateHiddenPreview();
     addWorkspaceRepaint(visibleRect());
     workspace()->clientHidden(this);
+    if (Compositor::isCreated()) {
+        Compositor::self()->checkUnredirect();
+    }
     emit windowHidden(this);
 }
 
@@ -1008,6 +1014,9 @@
     updateHiddenPreview();
     addWorkspaceRepaint(visibleRect());
     workspace()->clientHidden(this);
+    if (Compositor::isCreated()) {
+        Compositor::self()->checkUnredirect();
+    }
 }
 
 /**
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/client.h kwin-lowlatency/client.h
--- kwin-5.16.2/client.h	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/client.h	2019-06-25 23:16:16.645094300 +0300
@@ -349,6 +349,7 @@
 
 protected:
     virtual void debug(QDebug& stream) const;
+    virtual bool shouldUnredirect() const;
     void addDamage(const QRegion &damage) override;
     bool belongsToSameApplication(const AbstractClient *other, SameApplicationChecks checks) const override;
     void doSetActive() override;
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/CMakeLists.txt kwin-lowlatency/CMakeLists.txt
--- kwin-5.16.2/CMakeLists.txt	2019-06-25 14:44:41.000000000 +0300
+++ kwin-lowlatency/CMakeLists.txt	2019-06-25 23:16:16.630094325 +0300
@@ -37,6 +37,8 @@
          TYPE OPTIONAL
          )
 add_feature_info("Qt5Test" Qt5Test_FOUND "Required for building tests")
+
+# issue #6. will fix later.
 if (NOT Qt5Test_FOUND)
     set(BUILD_TESTING OFF CACHE BOOL "Build the testing tree.")
 endif()
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/composite.cpp kwin-lowlatency/composite.cpp
--- kwin-5.16.2/composite.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/composite.cpp	2019-06-25 23:16:16.646094298 +0300
@@ -60,6 +60,12 @@
 
 #include <xcb/composite.h>
 #include <xcb/damage.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <libdrm/drm.h>
+
+#include <sys/stat.h>
 
 Q_DECLARE_METATYPE(KWin::Compositor::SuspendReason)
 
@@ -90,16 +96,21 @@
     , vBlankInterval(0)
     , fpsInterval(0)
     , m_xrrRefreshRate(0)
+    , forceUnredirectCheck(false)
     , m_finishing(false)
     , m_starting(false)
     , m_timeSinceLastVBlank(0)
     , m_scene(NULL)
     , m_bufferSwapPending(false)
     , m_composeAtSwapCompletion(false)
+    , m_idle(false)
 {
     qRegisterMetaType<Compositor::SuspendReason>("Compositor::SuspendReason");
+    connect(&unredirectTimer, SIGNAL(timeout()), SLOT(delayedCheckUnredirect()));
     connect(&compositeResetTimer, SIGNAL(timeout()), SLOT(restart()));
     connect(options, &Options::configChanged, this, &Compositor::slotConfigChanged);
+    connect(options, SIGNAL(unredirectFullscreenChanged()), SLOT(delayedCheckUnredirect()));
+    unredirectTimer.setSingleShot(true);
     compositeResetTimer.setSingleShot(true);
     m_monotonicClock.start();
 
@@ -712,6 +723,7 @@
     if (repaints_region.isEmpty() && !windowRepaintsPending()) {
         m_scene->idle();
         m_timeSinceLastVBlank = fpsInterval - (options->vBlankTime() + 1); // means "start now"
+        m_idle=true;
         // Note: It would seem here we should undo suspended unredirect, but when scenes need
         // it for some reason, e.g. transformations or translucency, the next pass that does not
         // need this anymore and paints normally will also reset the suspended unredirect.
@@ -772,6 +784,14 @@
     if (m_bufferSwapPending && m_scene->syncsToVBlank()) {
         m_composeAtSwapCompletion = true;
     } else {
+        if (m_idle) {
+          m_idle=false;
+          m_totalSkips--;
+          if (m_totalSkips<0) m_totalSkips=0;
+          // TODO: improve this thing
+          m_lastPaintFree=2000;
+        }
+        usleep(m_lastPaintFree);
         scheduleRepaint();
     }
 }
@@ -885,6 +905,59 @@
             waitTime = 1; // ... "0" would be sufficient, but the compositor isn't the WMs only task
         }
     }
+    //printf("waitTime: %d\n",waitTime);
+    if (waitTime<4) waitTime=4;
+    m_totalSkips-=0.004;
+    if (m_totalSkips<0) {
+      m_totalSkips=0;
+    }
+    if ((signed)(m_lastPaintFree-2000)>(signed)((waitTime*1000)-4000)) {
+      m_totalSkips++;
+      switch (options->latencyControl()) {
+        case 0: // favor responsive
+          m_lastPaintFree=(waitTime*1000)-4000;
+          break;
+        case 2: // favor low-latency
+          m_lastPaintFree-=500;
+          break;
+        case 3: // aggressive
+          m_lastPaintFree-=300;
+          break;
+        case 1: default: // balanced
+          m_lastPaintFree-=500;
+          break;
+      }
+      //printf("\x1b[1;31mstutter\x1b[m\n");
+    } else {
+      switch (options->latencyControl()) {
+        case 0: // favor responsive
+          m_lastPaintFree=fmin((waitTime*1000)-4000,m_lastPaintFree+(50-m_totalSkips*5));
+          break;
+        case 2: // favor low-latency
+          m_lastPaintFree=fmin((waitTime*1000)-4000,m_lastPaintFree+(500-m_totalSkips*30));
+          break;
+        case 3: // aggressive
+          m_lastPaintFree=fmin((waitTime*1000)-4000,m_lastPaintFree+(1000-m_totalSkips*30));
+          break;
+        case 1: default: // balanced
+          m_lastPaintFree=fmin((waitTime*1000)-4000,m_lastPaintFree+(200-m_totalSkips*20));
+          break;
+      }
+    }
+    if (m_lastPaintFree<options->minLatency()*1000) {
+      m_lastPaintFree=options->minLatency()*1000;
+    }
+    if (m_lastPaintFree<1) {
+      m_lastPaintFree=1;
+    }
+    if (m_lastPaintFree>options->maxLatency()*1000) {
+      m_lastPaintFree=options->maxLatency()*1000;
+    }
+    if (m_totalSkips>10) {
+      m_totalSkips=10;
+    }
+    //printf("LPF: %d ts: %.2f\n",m_lastPaintFree,m_totalSkips);
+    waitTime=0;
     compositeTimer.start(qMin(waitTime, 250u), this); // force 4fps minimum
 }
 
@@ -893,6 +966,54 @@
     return !m_finishing && hasScene();
 }
 
+void Compositor::checkUnredirect()
+{
+    checkUnredirect(false);
+}
+
+// force is needed when the list of windows changes (e.g. a window goes away)
+void Compositor::checkUnredirect(bool force)
+{
+    if (!hasScene() || !m_scene->overlayWindow() || m_scene->overlayWindow()->window() == None || !options->isUnredirectFullscreen())
+        return;
+    if (force)
+        forceUnredirectCheck = true;
+    if (!unredirectTimer.isActive())
+        unredirectTimer.start(0);
+}
+
+void Compositor::delayedCheckUnredirect()
+{
+    if (!hasScene() || !m_scene->overlayWindow() || m_scene->overlayWindow()->window() == None || !(options->isUnredirectFullscreen() || sender() == options))
+        return;
+    ToplevelList list;
+    bool changed = forceUnredirectCheck;
+    foreach (Client * c, Workspace::self()->clientList())
+        list.append(c);
+    foreach (Unmanaged * c, Workspace::self()->unmanagedList())
+        list.append(c);
+    foreach (Toplevel * c, list) {
+        if (c->updateUnredirectedState()) {
+            changed = true;
+            break;
+        }
+    }
+    // no desktops, no Deleted ones
+    if (!changed)
+        return;
+    forceUnredirectCheck = false;
+    // Cut out parts from the overlay window where unredirected windows are,
+    // so that they are actually visible.
+    const QSize &s = screens()->size();
+    QRegion reg(0, 0, s.width(), s.height());
+    foreach (Toplevel * c, list) {
+        if (c->unredirected())
+            reg -= c->geometry();
+    }
+    m_scene->overlayWindow()->setShape(reg);
+    addRepaint(reg);
+}
+
 bool Compositor::checkForOverlayWindow(WId w) const
 {
     if (!hasScene()) {
@@ -946,8 +1067,10 @@
 
     damage_region = QRegion(0, 0, width(), height());
     effect_window = new EffectWindowImpl(this);
-
+    unredirect = false;
+ 
     Compositor::self()->scene()->addToplevel(this);
+    Compositor::self()->checkUnredirect(true);
 
     return true;
 }
@@ -956,6 +1079,7 @@
 {
     if (kwinApp()->operationMode() == Application::OperationModeX11 && damage_handle == XCB_NONE)
         return;
+    Compositor::self()->checkUnredirect(true);
     if (effect_window->window() == this) { // otherwise it's already passed to Deleted, don't free data
         discardWindowPixmap();
         delete effect_window;
@@ -972,6 +1096,42 @@
     effect_window = NULL;
 }
 
+bool Toplevel::updateUnredirectedState()
+{
+    assert(compositing());
+    bool should = options->isUnredirectFullscreen() && shouldUnredirect() && !unredirectSuspend &&
+                  !shape() && !hasAlpha() && opacity() == 1.0 &&
+                  !static_cast<EffectsHandlerImpl*>(effects)->activeFullScreenEffect();
+    if (should) usleep(50000);
+    if (should == unredirect)
+        return false;
+    static QElapsedTimer lastUnredirect;
+    static const qint64 msecRedirectInterval = 100;
+    if (!lastUnredirect.hasExpired(msecRedirectInterval)) {
+        QTimer::singleShot(msecRedirectInterval, Compositor::self(), SLOT(checkUnredirect()));
+        return false;
+    }
+    lastUnredirect.start();
+    unredirect = should;
+    if (unredirect) {
+        qCDebug(KWIN_CORE) << "Unredirecting:" << this;
+        xcb_composite_unredirect_window(connection(), frameId(), XCB_COMPOSITE_REDIRECT_MANUAL);
+    } else {
+        qCDebug(KWIN_CORE) << "Redirecting:" << this;
+        xcb_composite_redirect_window(connection(), frameId(), XCB_COMPOSITE_REDIRECT_MANUAL);
+        discardWindowPixmap();
+    }
+    return true;
+}
+
+void Toplevel::suspendUnredirect(bool suspend)
+{
+    if (unredirectSuspend == suspend)
+        return;
+    unredirectSuspend = suspend;
+    Compositor::self()->checkUnredirect();
+}
+
 void Toplevel::discardWindowPixmap()
 {
     addDamageFull();
@@ -1189,4 +1349,75 @@
     resetHaveResizeEffect();
 }
 
+// TODO THIS
+bool Client::shouldUnredirect() const
+{
+    if (isActiveFullScreen()) {
+        ToplevelList stacking = workspace()->xStackingOrder();
+        for (int pos = stacking.count() - 1;
+                pos >= 0;
+                --pos) {
+            Toplevel* c = stacking.at(pos);
+            if (c == this) {   // is not covered by any other window, ok to unredirect
+                //printf("yes.\n");
+                return true;
+            }
+            if (c->geometry().intersects(geometry())) {
+                // check whether this is an invisible floating icon at the top left corner
+                if (c->geometry()==QRect(0,0,32,32)) {
+                  //printf("yes via hack.\n");
+                  return true;
+                }
+                //printf("no. this: %d %d %d %d. other: %d %d %d %d.\n",geometry().x(),geometry().y(),geometry().width(),geometry().height(),c->geometry().x(),c->geometry().y(),c->geometry().width(),c->geometry().height());
+                return false;
+            }
+        }
+        //printf("ABORT\n");
+        abort();
+    }
+    return false;
+}
+
+
+//****************************************
+// Unmanaged
+//****************************************
+
+bool Unmanaged::shouldUnredirect() const
+{
+    // the pixmap is needed for the login effect, a nicer solution would be the login effect increasing
+    // refcount for the window pixmap (which would prevent unredirect), avoiding this hack
+    if (resourceClass() == "ksplashx"
+            || resourceClass() == "ksplashsimple"
+            || resourceClass() == "ksplashqml"
+            )
+        return false;
+// it must cover whole display or one xinerama screen, and be the topmost there
+    const int desktop = VirtualDesktopManager::self()->current();
+    if (geometry() == workspace()->clientArea(FullArea, geometry().center(), desktop)
+            || geometry() == workspace()->clientArea(ScreenArea, geometry().center(), desktop)) {
+        ToplevelList stacking = workspace()->xStackingOrder();
+        for (int pos = stacking.count() - 1;
+                pos >= 0;
+                --pos) {
+            Toplevel* c = stacking.at(pos);
+            if (c == this)   // is not covered by any other window, ok to unredirect
+                return true;
+            if (c->geometry().intersects(geometry()))
+                return false;
+        }
+        abort();
+    }
+    return false;
+}
+
+//****************************************
+// Deleted
+//****************************************
+
+bool Deleted::shouldUnredirect() const
+{
+    return false;
+}
+
 } // namespace
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/composite.h kwin-lowlatency/composite.h
--- kwin-5.16.2/composite.h	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/composite.h	2019-06-25 23:16:16.646094298 +0300
@@ -158,6 +158,8 @@
      * Schedules a new repaint if no repaint is currently scheduled.
      **/
     void scheduleRepaint();
+    void checkUnredirect();
+    void checkUnredirect(bool force);
     void updateCompositeBlocking();
     void updateCompositeBlocking(KWin::Client* c);
 
@@ -196,6 +198,7 @@
      **/
     void restart();
     void performCompositing();
+    void delayedCheckUnredirect();
     void slotConfigChanged();
     void releaseCompositorSelection();
     void deleteUnusedSupportProperties();
@@ -224,6 +227,8 @@
     int m_xrrRefreshRate;
     QRegion repaints_region;
 
+    QTimer unredirectTimer;
+    bool forceUnredirectCheck;
     QTimer compositeResetTimer; // for compressing composite resets
     bool m_finishing; // finish() sets this variable while shutting down
     bool m_starting; // start() sets this variable while starting
@@ -234,6 +239,11 @@
     int m_framesToTestForSafety = 3;
     QElapsedTimer m_monotonicClock;
 
+    // low-latency stuff
+    int m_lastPaintFree=8000;
+    float m_totalSkips=0;
+    bool m_idle;
+
     KWIN_SINGLETON_VARIABLE(Compositor, s_compositor)
 };
 }
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/deleted.h kwin-lowlatency/deleted.h
--- kwin-5.16.2/deleted.h	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/deleted.h	2019-06-25 23:16:16.648094295 +0300
@@ -186,6 +186,7 @@
 
 protected:
     virtual void debug(QDebug& stream) const;
+    virtual bool shouldUnredirect() const;
 
 private Q_SLOTS:
     void mainClientClosed(KWin::Toplevel *client);
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/CMakeLists.txt kwin-lowlatency/effects/CMakeLists.txt
--- kwin-5.16.2/effects/CMakeLists.txt	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/effects/CMakeLists.txt	2019-06-25 23:16:16.659094276 +0300
@@ -87,6 +87,7 @@
     magnifier/magnifier.cpp
     mouseclick/mouseclick.cpp
     mousemark/mousemark.cpp
+    mousepos/mousepos.cpp
     presentwindows/presentwindows.cpp
     presentwindows/presentwindows_proxy.cpp
     resize/resize.cpp
@@ -118,6 +119,7 @@
     magnifier/magnifierconfig.kcfgc
     mouseclick/mouseclickconfig.kcfgc
     mousemark/mousemarkconfig.kcfgc
+    mousepos/mouseposconfig.kcfgc
     presentwindows/presentwindowsconfig.kcfgc
     resize/resizeconfig.kcfgc
     showfps/showfpsconfig.kcfgc
@@ -182,6 +184,7 @@
 add_subdirectory( magnifier )
 add_subdirectory( mouseclick )
 add_subdirectory( mousemark )
+add_subdirectory( mousepos )
 include( screenshot/CMakeLists.txt )
 include( sheet/CMakeLists.txt )
 include( snaphelper/CMakeLists.txt )
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/effect_builtins.cpp kwin-lowlatency/effects/effect_builtins.cpp
--- kwin-5.16.2/effects/effect_builtins.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/effects/effect_builtins.cpp	2019-06-25 23:16:16.664094268 +0300
@@ -54,6 +54,7 @@
 #include "magnifier/magnifier.h"
 #include "mouseclick/mouseclick.h"
 #include "mousemark/mousemark.h"
+#include "mousepos/mousepos.h"
 #include "sheet/sheet.h"
 #include "snaphelper/snaphelper.h"
 #include "startupfeedback/startupfeedback.h"
@@ -381,6 +382,21 @@
         nullptr,
         nullptr
 #endif
+EFFECT_FALLBACK
+    }, {
+        QStringLiteral("mousepos"),
+        i18ndc("kwin_effects", "Name of a KWin Effect", "Paint cursor"),
+        i18ndc("kwin_effects", "Comment describing the KWin Effect", "Redraw the mouse cursor for capturing the display using kmsgrab in FFmpeg"),
+        QStringLiteral("Tools"),
+        QString(),
+        QUrl(),
+        false,
+        false,
+#ifdef EFFECT_BUILTINS
+        &createHelper<MousePosEffect>,
+        nullptr,
+        nullptr
+#endif
 EFFECT_FALLBACK
     }, {
         QStringLiteral("presentwindows"),
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/effect_builtins.h kwin-lowlatency/effects/effect_builtins.h
--- kwin-5.16.2/effects/effect_builtins.h	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/effects/effect_builtins.h	2019-06-25 23:16:16.664094268 +0300
@@ -53,6 +53,7 @@
     Magnifier,
     MouseClick,
     MouseMark,
+    MousePos,
     PresentWindows,
     Resize,
     ScreenEdge,
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/CMakeLists.txt kwin-lowlatency/effects/mousepos/CMakeLists.txt
--- kwin-5.16.2/effects/mousepos/CMakeLists.txt	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/CMakeLists.txt	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,25 @@
+#######################################
+# Config
+set(kwin_mousepos_config_SRCS mousepos_config.cpp)
+ki18n_wrap_ui(kwin_mousepos_config_SRCS mousepos_config.ui)
+qt5_add_dbus_interface(kwin_mousepos_config_SRCS ${kwin_effects_dbus_xml} kwineffects_interface)
+kconfig_add_kcfg_files(kwin_mousepos_config_SRCS mouseposconfig.kcfgc)
+
+add_library(kwin_mousepos_config MODULE ${kwin_mousepos_config_SRCS})
+
+target_link_libraries(kwin_mousepos_config
+    KF5::ConfigWidgets
+    KF5::GlobalAccel
+    KF5::I18n
+    KF5::Service
+    KF5::XmlGui
+)
+
+kcoreaddons_desktop_to_json(kwin_mousepos_config mousepos_config.desktop SERVICE_TYPES kcmodule.desktop)
+
+install(
+    TARGETS
+        kwin_mousepos_config
+    DESTINATION
+        ${PLUGIN_INSTALL_DIR}/kwin/effects/configs
+)
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/data/1.10/motion.frag kwin-lowlatency/effects/mousepos/data/1.10/motion.frag
--- kwin-5.16.2/effects/mousepos/data/1.10/motion.frag	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/data/1.10/motion.frag	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,43 @@
+#version 140
+
+// thanks Steven Lu
+
+uniform sampler2D sampler;
+in vec2 f_sceneCoord; // this should be pretransformed texcoord to scene tex
+// it is also appropriate to use as a "this pixel" position
+// (in relation to center, etc)
+varying float f_alpha;
+varying vec2 f_center;
+in vec3 f_vel;
+in float samples;
+varying mat2 rot_per_sample;
+
+out vec4 fragColor;
+
+void main (void) {
+vec2 original_center = f_center - f_vel.xy;
+// vel.xy is actually just the dist
+vec4 accum = vec4(0,0,0,0);
+mat2 cumulativeRotation;
+// set identity rotation matrix
+cumulativeRotation[0] = vec2(1,0); cumulativeRotation[1] = vec2(0,
+1);
+float samples_i = ceil(samples);
+for(int i=0;i<samples_i;++i) {
+float fraction = float(i)/samples_i;
+vec2 pos = cumulativeRotation*(f_sceneCoord+f_vel.xy*fraction-f_center)+ f_center;
+if (pos.x>1.0f || pos.x<0.0f || pos.y>1.0f || pos.y<0.0f) continue;
+vec4 col = texture2D(sampler, pos);
+//col=vec4(0.0f,0.0f,0.0f,0.0f);
+// 1: translate to orig ctr 2: rotate by i*rot
+// 3: translate back to origctr+(curctr-origctr)*i
+if (col.a>0.01f) { accum = accum + vec4(col.rgba); }
+cumulativeRotation = cumulativeRotation * rot_per_sample;
+}
+if (accum.a < 1.0/1024.) discard; // prevent divide by zero
+fragColor = vec4(accum.rgb*(1.0/accum.a),accum.a/samples_i);
+//fragColor=vec4(texture2D(sampler, f_sceneCoord));
+//fragColor=vec4(1.0f,1.0f,1.0f,1.0f);
+// This should be a non-premultiplied alpha value for use with
+// saturate blending.
+}
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/data/1.10/motion.vert kwin-lowlatency/effects/mousepos/data/1.10/motion.vert
--- kwin-5.16.2/effects/mousepos/data/1.10/motion.vert	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/data/1.10/motion.vert	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,61 @@
+#version 140
+
+// thanks Steven Lu
+
+// KWin
+uniform mat4 projection;
+uniform mat4 modelview;
+uniform mat4 modelViewProjectionMatrix;
+uniform mat4 textureMatrix;
+
+in vec4 position;
+in vec4 texcoord;
+
+uniform mat4 mvm;
+uniform vec2 viewport;
+uniform vec2 in_pos;
+// this is vertex position
+uniform vec2 in_center;
+uniform vec4 in_vel;
+uniform vec2 in_sizes;
+// those were the per-object velocity related quantities
+// I pack omega*dt into in_vel.z, and in_vel.w is max-displacement
+// for calculating samples
+uniform float in_alpha;
+varying float f_alpha;
+varying vec2 f_center;
+out vec3 f_vel;
+out float samples; // # of samples to blur
+varying mat2 rot_per_sample; // A special scale-rotate matrix
+out vec2 f_sceneCoord; // NDC to tex coord
+varying mat4 f_scale;
+void main (void) {
+mat4 proj_modelview_mat = projection * modelview;
+f_scale[0]=vec4(1.0+abs(in_vel.x),0.0,0.0,-abs(in_vel.x)*(in_pos.x+((sign(in_vel.x)>0.5)?in_sizes.x:0.0)));
+f_scale[1]=vec4(0.0,1.0+abs(in_vel.y),0.0,-abs(in_vel.y)*(in_pos.y+((sign(in_vel.y)>0.5)?in_sizes.y:0.0)));
+f_scale[2]=vec4(0.0,0.0,1.0,0.0);
+f_scale[3]=vec4(0.0,0.0,0.0,1.0);
+/*f_scale[0]=vec4(1.0,0.0,0.0,0.0);
+f_scale[1]=vec4(0.0,1.0,0.0,0.0);
+f_scale[2]=vec4(0.0,0.0,1.0,0.0);
+f_scale[3]=vec4(0.0,0.0,0.0,1.0);*/
+gl_Position = modelViewProjectionMatrix * vec4(gl_Vertex.xyzw*f_scale);
+f_sceneCoord = vec2( texcoord)*(1+abs(in_vel.xy))-max(vec2(0.0,0.0),in_vel.xy);
+f_center = ((modelViewProjectionMatrix * vec4(in_center,0.0,1.0)).xy
++ vec2(1.0,1.0))*0.5; // transform the center to clip space
+f_vel.xy=in_vel.xy;
+//f_vel.xy = (proj_modelview_mat * vec4(in_vel.xy,0.0,0.0)).xy * 0.5;
+// velocity also need to be in clip space
+// careful! We don't shift this one, only scale
+f_vel.z = in_vel.z; // Store omega in z-comp in radians
+samples = min(50,(modelViewProjectionMatrix * vec4(in_vel.w,0,0,0)).x
+* viewport.x * 2 + 1);
+// w here is not omega it is the max disp value from CPU
+float theta = in_vel.z/(samples);
+float cost = cos(theta); float sint = sin(theta);
+float aspect = viewport.x/viewport.y;
+rot_per_sample[0] = vec2(cost,sint*aspect); rot_per_sample[1] = vec2(-sint/aspect,cost);
+// the rotation matrix is actually a scale and rotate matrix.
+// the rotation must be correct in world space but is manipulated by the
+// fragment shader in NDC which requires aspect correction.
+}
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/data/1.40/motion.frag kwin-lowlatency/effects/mousepos/data/1.40/motion.frag
--- kwin-5.16.2/effects/mousepos/data/1.40/motion.frag	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/data/1.40/motion.frag	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,43 @@
+#version 140
+
+// thanks Steven Lu
+
+uniform sampler2D sampler;
+in vec2 f_sceneCoord; // this should be pretransformed texcoord to scene tex
+// it is also appropriate to use as a "this pixel" position
+// (in relation to center, etc)
+varying float f_alpha;
+varying vec2 f_center;
+in vec3 f_vel;
+in float samples;
+varying mat2 rot_per_sample;
+
+out vec4 fragColor;
+
+void main (void) {
+vec2 original_center = f_center - f_vel.xy;
+// vel.xy is actually just the dist
+vec4 accum = vec4(0,0,0,0);
+mat2 cumulativeRotation;
+// set identity rotation matrix
+cumulativeRotation[0] = vec2(1,0); cumulativeRotation[1] = vec2(0,
+1);
+float samples_i = ceil(samples);
+for(int i=0;i<samples_i;++i) {
+float fraction = float(i)/samples_i;
+vec2 pos = cumulativeRotation*(f_sceneCoord+f_vel.xy*fraction-f_center)+ f_center;
+if (pos.x>1.0f || pos.x<0.0f || pos.y>1.0f || pos.y<0.0f) continue;
+vec4 col = texture2D(sampler, pos);
+//col=vec4(0.0f,0.0f,0.0f,0.0f);
+// 1: translate to orig ctr 2: rotate by i*rot
+// 3: translate back to origctr+(curctr-origctr)*i
+if (col.a>0.01f) { accum = accum + vec4(col.rgba); }
+cumulativeRotation = cumulativeRotation * rot_per_sample;
+}
+if (accum.a < 1.0/1024.) discard; // prevent divide by zero
+fragColor = vec4(accum.rgb*(1.0/accum.a),accum.a/samples_i);
+//fragColor=vec4(texture2D(sampler, f_sceneCoord));
+//fragColor=vec4(1.0f,1.0f,1.0f,1.0f);
+// This should be a non-premultiplied alpha value for use with
+// saturate blending.
+}
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/data/1.40/motion.vert kwin-lowlatency/effects/mousepos/data/1.40/motion.vert
--- kwin-5.16.2/effects/mousepos/data/1.40/motion.vert	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/data/1.40/motion.vert	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,61 @@
+#version 140
+
+// thanks Steven Lu
+
+// KWin
+uniform mat4 projection;
+uniform mat4 modelview;
+uniform mat4 modelViewProjectionMatrix;
+uniform mat4 textureMatrix;
+
+in vec4 position;
+in vec4 texcoord;
+
+uniform mat4 mvm;
+uniform vec2 viewport;
+uniform vec2 in_pos;
+// this is vertex position
+uniform vec2 in_center;
+uniform vec4 in_vel;
+uniform vec2 in_sizes;
+// those were the per-object velocity related quantities
+// I pack omega*dt into in_vel.z, and in_vel.w is max-displacement
+// for calculating samples
+uniform float in_alpha;
+varying float f_alpha;
+varying vec2 f_center;
+out vec3 f_vel;
+out float samples; // # of samples to blur
+varying mat2 rot_per_sample; // A special scale-rotate matrix
+out vec2 f_sceneCoord; // NDC to tex coord
+varying mat4 f_scale;
+void main (void) {
+mat4 proj_modelview_mat = projection * modelview;
+f_scale[0]=vec4(1.0+abs(in_vel.x),0.0,0.0,-abs(in_vel.x)*(in_pos.x+((sign(in_vel.x)>0.5)?in_sizes.x:0.0)));
+f_scale[1]=vec4(0.0,1.0+abs(in_vel.y),0.0,-abs(in_vel.y)*(in_pos.y+((sign(in_vel.y)>0.5)?in_sizes.y:0.0)));
+f_scale[2]=vec4(0.0,0.0,1.0,0.0);
+f_scale[3]=vec4(0.0,0.0,0.0,1.0);
+/*f_scale[0]=vec4(1.0,0.0,0.0,0.0);
+f_scale[1]=vec4(0.0,1.0,0.0,0.0);
+f_scale[2]=vec4(0.0,0.0,1.0,0.0);
+f_scale[3]=vec4(0.0,0.0,0.0,1.0);*/
+gl_Position = modelViewProjectionMatrix * vec4(gl_Vertex.xyzw*f_scale);
+f_sceneCoord = vec2( texcoord)*(1+abs(in_vel.xy))-max(vec2(0.0,0.0),in_vel.xy);
+f_center = ((modelViewProjectionMatrix * vec4(in_center,0.0,1.0)).xy
++ vec2(1.0,1.0))*0.5; // transform the center to clip space
+f_vel.xy=in_vel.xy;
+//f_vel.xy = (proj_modelview_mat * vec4(in_vel.xy,0.0,0.0)).xy * 0.5;
+// velocity also need to be in clip space
+// careful! We don't shift this one, only scale
+f_vel.z = in_vel.z; // Store omega in z-comp in radians
+samples = min(50,(modelViewProjectionMatrix * vec4(in_vel.w,0,0,0)).x
+* viewport.x * 2 + 1);
+// w here is not omega it is the max disp value from CPU
+float theta = in_vel.z/(samples);
+float cost = cos(theta); float sint = sin(theta);
+float aspect = viewport.x/viewport.y;
+rot_per_sample[0] = vec2(cost,sint*aspect); rot_per_sample[1] = vec2(-sint/aspect,cost);
+// the rotation matrix is actually a scale and rotate matrix.
+// the rotation must be correct in world space but is manipulated by the
+// fragment shader in NDC which requires aspect correction.
+}
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/mousepos_config.cpp kwin-lowlatency/effects/mousepos/mousepos_config.cpp
--- kwin-5.16.2/effects/mousepos/mousepos_config.cpp	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/mousepos_config.cpp	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,123 @@
+/********************************************************************
+ KWin - the KDE window manager
+ This file is part of the KDE project.
+
+Copyright (C) 2007 Rivo Laks <rivolaks@hot.ee>
+Copyright (C) 2010 Jorge Mata <matamax123@gmail.com>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*********************************************************************/
+
+#include <QAction>
+#include <config-kwin.h>
+#include <kwineffects_interface.h>
+
+#include <KLocalizedString>
+#include <KActionCollection>
+#include <KAboutData>
+#include <KGlobalAccel>
+#include <KPluginFactory>
+
+#include <QVBoxLayout>
+#include <QLabel>
+
+#include "mousepos_config.h"
+
+// KConfigSkeleton
+#include "mouseposconfig.h"
+
+K_PLUGIN_FACTORY_WITH_JSON(MousePosEffectConfigFactory,
+                           "mousepos_config.json",
+                           registerPlugin<KWin::MousePosEffectConfig>();)
+
+namespace KWin
+{
+
+MousePosEffectConfigForm::MousePosEffectConfigForm(QWidget* parent) : QWidget(parent)
+{
+    setupUi(this);
+}
+
+MousePosEffectConfig::MousePosEffectConfig(QWidget* parent, const QVariantList& args) :
+    KCModule(KAboutData::pluginData(QStringLiteral("mousepos")), parent, args)
+{
+    MousePosConfig::instance(KWIN_CONFIG);
+    m_ui = new MousePosEffectConfigForm(this);
+    QVBoxLayout* layout = new QVBoxLayout(this);
+    layout->addWidget(m_ui);
+
+    addConfig(MousePosConfig::self(), m_ui);
+
+    m_actionCollection = new KActionCollection(this, QStringLiteral("kwin"));
+    m_actionCollection->setComponentDisplayName(i18n("KWin"));
+    m_actionCollection->setConfigGroup(QStringLiteral("MousePos"));
+    m_actionCollection->setConfigGlobal(true);
+
+    QAction *a = m_actionCollection->addAction(QStringLiteral("MousePos"));
+    a->setText(i18n("Paint cursor"));
+    a->setProperty("isConfigurationAction", true);
+
+    KGlobalAccel::self()->setDefaultShortcut(a, QList<QKeySequence>());
+    KGlobalAccel::self()->setShortcut(a, QList<QKeySequence>());
+
+    connect(m_ui->kcfg_mpMotionBlur, SIGNAL(keySequenceChanged(QKeySequence)),
+                            SLOT(shortcutChanged(QKeySequence)));
+
+    load();
+}
+
+MousePosEffectConfig::~MousePosEffectConfig()
+{
+}
+
+void MousePosEffectConfig::checkModifiers()
+{
+}
+
+void MousePosEffectConfig::load()
+{
+    KCModule::load();
+
+    checkModifiers();
+    emit changed(false);
+}
+
+void MousePosEffectConfig::save()
+{
+    KCModule::save();
+    m_actionCollection->writeSettings();
+    OrgKdeKwinEffectsInterface interface(QStringLiteral("org.kde.KWin"),
+                                         QStringLiteral("/Effects"),
+                                         QDBusConnection::sessionBus());
+    interface.reconfigureEffect(QStringLiteral("mousepos"));
+}
+
+void MousePosEffectConfig::defaults()
+{
+    KCModule::defaults();
+    checkModifiers();
+}
+
+void MousePosEffectConfig::shortcutChanged(const QKeySequence &seq)
+{
+    /*if (QAction *a = m_actionCollection->action(QStringLiteral("MousePos"))) {
+        KGlobalAccel::self()->setShortcut(a, QList<QKeySequence>() << seq, KGlobalAccel::NoAutoloading);
+    }*/
+//     m_actionCollection->writeSettings();
+    emit changed(true);
+}
+
+} // namespace
+
+#include "mousepos_config.moc"
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/mousepos_config.desktop kwin-lowlatency/effects/mousepos/mousepos_config.desktop
--- kwin-5.16.2/effects/mousepos/mousepos_config.desktop	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/mousepos_config.desktop	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,10 @@
+[Desktop Entry]
+Type=Service
+X-KDE-ServiceTypes=KCModule
+
+X-KDE-Library=kwin_mousepos_config
+X-KDE-ParentComponents=mousepos
+
+Name=Paint cursor
+Name[es]=Pintar cursor
+Name[x-test]=xxPaint Cursorxx
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/mousepos_config.h kwin-lowlatency/effects/mousepos/mousepos_config.h
--- kwin-5.16.2/effects/mousepos/mousepos_config.h	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/mousepos_config.h	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,62 @@
+/********************************************************************
+ KWin - the KDE window manager
+ This file is part of the KDE project.
+
+Copyright (C) 2007 Rivo Laks <rivolaks@hot.ee>
+Copyright (C) 2010 Jorge Mata <matamax123@gmail.com>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*********************************************************************/
+
+#ifndef KWIN_MOUSEPOS_CONFIG_H
+#define KWIN_MOUSEPOS_CONFIG_H
+
+#include <kcmodule.h>
+
+#include "ui_mousepos_config.h"
+
+class KActionCollection;
+
+namespace KWin
+{
+
+class MousePosEffectConfigForm : public QWidget, public Ui::MousePosEffectConfigForm
+{
+    Q_OBJECT
+public:
+    explicit MousePosEffectConfigForm(QWidget* parent);
+};
+
+class MousePosEffectConfig : public KCModule
+{
+    Q_OBJECT
+public:
+    explicit MousePosEffectConfig(QWidget* parent = 0, const QVariantList& args = QVariantList());
+    ~MousePosEffectConfig();
+
+public Q_SLOTS:
+    virtual void save();
+    virtual void load();
+    virtual void defaults();
+private Q_SLOTS:
+    void shortcutChanged(const QKeySequence &seq);
+private:
+    void checkModifiers();
+    MousePosEffectConfigForm* m_ui;
+    KActionCollection* m_actionCollection;
+};
+
+} // namespace
+
+#endif
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/mouseposconfig.kcfgc kwin-lowlatency/effects/mousepos/mouseposconfig.kcfgc
--- kwin-5.16.2/effects/mousepos/mouseposconfig.kcfgc	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/mouseposconfig.kcfgc	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,5 @@
+File=mousepos.kcfg
+ClassName=MousePosConfig
+NameSpace=KWin
+Singleton=true
+Mutators=true
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/mousepos_config.ui kwin-lowlatency/effects/mousepos/mousepos_config.ui
--- kwin-5.16.2/effects/mousepos/mousepos_config.ui	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/mousepos_config.ui	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>KWin::MousePosEffectConfigForm</class>
+ <widget class="QWidget" name="KWin::MousePosEffectConfigForm">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>400</width>
+    <height>36</height>
+   </rect>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout">
+   <item>
+    <widget class="QCheckBox" name="kcfg_mpMotionBlur">
+     <property name="text">
+      <string>Motion blur</string>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/mousepos.cpp kwin-lowlatency/effects/mousepos/mousepos.cpp
--- kwin-5.16.2/effects/mousepos/mousepos.cpp	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/mousepos.cpp	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,236 @@
+/********************************************************************
+ KWin - the KDE window manager
+ This file is part of the KDE project.
+
+Copyright (C) 2006 Lubos Lunak <l.lunak@kde.org>
+Copyright (C) 2010 Jorge Mata <matamax123@gmail.com>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*********************************************************************/
+
+#include "mousepos.h"
+
+// KConfigSkeleton
+#include "mouseposconfig.h"
+
+#include <QAction>
+#include <QPainter>
+#include <QTime>
+#include <QMatrix4x4>
+
+#include <kwinconfig.h>
+#include <kwinglutils.h>
+#include <kwinxrenderutils.h>
+
+#include <KGlobalAccel>
+#include <KLocalizedString>
+
+#include <math.h>
+
+namespace KWin
+{
+
+MousePosEffect::MousePosEffect()
+    : m_active(false)
+    , m_inited(false)
+    , m_valid(true)
+{
+    initConfig<MousePosConfig>();
+    m_mousePolling = false;
+
+    m_action = new QAction(this);
+    m_action->setObjectName(QStringLiteral("MousePos"));
+    m_action->setText(i18n("Paint cursor"));
+    //KGlobalAccel::self()->setDefaultShortcut(m_action, QList<QKeySequence>());
+    //KGlobalAccel::self()->setShortcut(m_action, QList<QKeySequence>());
+    //effects->registerGlobalShortcut(QKeySequence(), m_action);
+
+    connect(m_action, SIGNAL(triggered(bool)), this, SLOT(toggle()));
+
+    connect(effects, SIGNAL(mouseChanged(QPoint,QPoint,Qt::MouseButtons,Qt::MouseButtons,Qt::KeyboardModifiers,Qt::KeyboardModifiers)),
+                     SLOT(slotMouseChanged(QPoint,QPoint,Qt::MouseButtons,Qt::MouseButtons,Qt::KeyboardModifiers,Qt::KeyboardModifiers)));
+    reconfigure(ReconfigureAll);
+    if (!m_mousePolling) {
+      effects->startMousePolling();
+      m_mousePolling = true;
+    }
+}
+
+MousePosEffect::~MousePosEffect()
+{
+    if (m_mousePolling)
+        effects->stopMousePolling();
+}
+
+void MousePosEffect::reconfigure(ReconfigureFlags)
+{
+    MousePosConfig::self()->read();
+}
+
+void MousePosEffect::prePaintScreen(ScreenPrePaintData& data, int time)
+{
+    if (m_active) {
+        QTime t = QTime::currentTime();
+        m_lastRect[0].moveCenter(cursorPos());
+        m_lastRect[1].moveCenter(cursorPos());
+        data.paint |= m_lastRect[0].adjusted(-1,-1,1,1);
+    }
+    effects->prePaintScreen(data, time);
+}
+
+bool MousePosEffect::loadData()
+{
+    m_inited = true;
+
+    m_shader = ShaderManager::instance()->generateShaderFromResources(ShaderTrait::MapTexture, QString("motion.vert"), QStringLiteral("motion.frag"));
+    if (!m_shader->isValid()) {
+        printf("failure.\n");
+        qCCritical(KWINEFFECTS) << "The shader failed to load!";
+        return false;
+    }
+    printf("shader loaded.\n");
+    return true;
+}
+
+void MousePosEffect::paintScreen(int mask, QRegion region, ScreenPaintData& data)
+{
+    effects->paintScreen(mask, region, data);   // paint normal screen
+    if (!m_active)
+        return;
+    auto c = xcbConnection();
+
+    if (m_valid && !m_inited)
+        m_valid = loadData();
+
+    if ( effects->isOpenGLCompositing()) {
+        QScopedPointer<xcb_xfixes_get_cursor_image_reply_t, QScopedPointerPodDeleter> cursor(
+        xcb_xfixes_get_cursor_image_reply(c,
+                                          xcb_xfixes_get_cursor_image_unchecked(c),
+                                          nullptr));
+    if (cursor.isNull()) {
+        return;
+    }       
+            QImage img = QImage((uchar *) xcb_xfixes_get_cursor_image_cursor_image(cursor.data()), cursor->width, cursor->height,
+                      QImage::Format_ARGB32_Premultiplied);
+            
+            if (img.isNull()) {
+                return;
+            }
+            m_cursorTexture.reset(new GLTexture(img));
+    // get cursor position in projection coordinates
+    if (!m_cursorTexture) {
+      return;
+    }
+    const QRect cursorRect(0, 0, m_cursorTexture->width(), m_cursorTexture->height());
+    QMatrix4x4 mvp = data.projectionMatrix();
+    mvp.translate(cursor->x-cursor->xhot, cursor->y-cursor->yhot);
+    
+    // handle transparence
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    
+    // paint texture in cursor offset
+    if (MousePosConfig::motionBlur()) {
+      m_cursorTexture->bind();
+      ShaderBinder binder(m_shader);
+      binder.shader()->setUniform(GLShader::ModelViewProjectionMatrix, mvp);
+      binder.shader()->setUniform("viewport",QVector2D(3840,2160));
+      binder.shader()->setUniform("in_center",QVector2D(0.0f,0.0f));
+      binder.shader()->setUniform("in_vel",QVector4D(((float)(cursor->x-cursor->xhot)-m_prevX)/(float)cursorRect.width()
+      ,((float)(cursor->y-cursor->yhot)-m_prevY)/(float)cursorRect.height()
+      ,0.0f,32.0f));
+      //binder.shader()->setUniform("in_pos",QVector2D(cursor->x-cursor->xhot+16, cursor->y-cursor->yhot));
+      binder.shader()->setUniform("in_pos",QVector2D(0,0));
+      binder.shader()->setUniform("in_sizes",QVector2D(cursorRect.width(),cursorRect.height()));
+      m_cursorTexture->render(QRegion(cursorRect), cursorRect);
+      m_cursorTexture->unbind();
+    } else {
+      m_cursorTexture->bind();
+      ShaderBinder obinder(ShaderTrait::MapTexture);
+      obinder.shader()->setUniform(GLShader::ModelViewProjectionMatrix, mvp);
+      m_cursorTexture->render(QRegion(cursorRect), cursorRect);
+      m_cursorTexture->unbind();
+    }
+
+    glDisable(GL_BLEND);
+    m_cursorTexture.reset(NULL);
+    
+    m_prevX=cursor->x-cursor->xhot;
+    m_prevY=cursor->y-cursor->yhot;
+    m_lastRect[1]=m_lastRect[0];
+    m_lastRect[0]=cursorRect;
+    m_lastRect[0].moveTo(m_prevX,m_prevY);
+    }
+}
+
+void MousePosEffect::postPaintScreen()
+{
+    if (m_lastRect[0]!=m_lastRect[1]) {
+        //effects->addRepaint(m_lastRect[0].adjusted(-1,-1,1,1));
+    }
+    effects->postPaintScreen();
+}
+
+bool MousePosEffect::init()
+{
+    effects->makeOpenGLContextCurrent();
+#ifdef KWIN_HAVE_XRENDER_COMPOSITING
+#else
+#endif
+    m_lastRect[0].moveCenter(cursorPos());
+    m_lastRect[1].moveCenter(cursorPos());
+    m_active = true;
+    printf("init...\n");
+    return true;
+}
+
+void MousePosEffect::toggle()
+{
+    m_mousePolling=true;
+    m_active=true;
+    printf("toggle\n");
+/*
+    if (m_mousePolling)
+        return;
+
+    if (m_active) {
+        m_active = false;
+    } else if (!init()) {
+        return;
+    }*/
+    effects->addRepaint(m_lastRect[0].adjusted(-1,-1,1,1));
+}
+
+void MousePosEffect::slotMouseChanged(const QPoint&, const QPoint&,
+                                        Qt::MouseButtons, Qt::MouseButtons,
+                                        Qt::KeyboardModifiers modifiers, Qt::KeyboardModifiers)
+{
+    if (!m_mousePolling) // we didn't ask for it but maybe someone else did...
+        return;
+    if (!m_active && !init()) {
+            return;
+        }
+        effects->addRepaint(m_lastRect[0].adjusted(-1,-1,1,1));
+}
+
+void MousePosEffect::loadTexture()
+{
+}
+
+bool MousePosEffect::isActive() const
+{
+    return m_active;
+}
+
+} // namespace
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/mousepos.h kwin-lowlatency/effects/mousepos/mousepos.h
--- kwin-5.16.2/effects/mousepos/mousepos.h	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/mousepos.h	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,79 @@
+/********************************************************************
+ KWin - the KDE window manager
+ This file is part of the KDE project.
+
+Copyright (C) 2006 Lubos Lunak <l.lunak@kde.org>
+Copyright (C) 2010 Jorge Mata <matamax123@gmail.com>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*********************************************************************/
+
+#ifndef KWIN_MOUSEPOS_H
+#define KWIN_MOUSEPOS_H
+
+#include <kwineffects.h>
+
+class QAction;
+
+namespace KWin
+{
+class GLTexture;
+
+class MousePosEffect
+    : public Effect
+{
+    Q_OBJECT
+    Q_PROPERTY(bool mousePolling READ isMousePolling)
+public:
+    MousePosEffect();
+    virtual ~MousePosEffect();
+    virtual void prePaintScreen(ScreenPrePaintData& data, int time);
+    virtual void paintScreen(int mask, QRegion region, ScreenPaintData& data);
+    virtual void postPaintScreen();
+    virtual void reconfigure(ReconfigureFlags);
+    virtual bool isActive() const;
+
+    // for properties
+    bool isMousePolling() const {
+        return m_mousePolling;
+    }
+protected:
+    bool loadData();
+private Q_SLOTS:
+    void toggle();
+    void slotMouseChanged(const QPoint& pos, const QPoint& old,
+                              Qt::MouseButtons buttons, Qt::MouseButtons oldbuttons,
+                              Qt::KeyboardModifiers modifiers, Qt::KeyboardModifiers oldmodifiers);
+private:
+    bool init();
+    void loadTexture();
+    QRect m_lastRect[2];
+    bool m_active, m_mousePolling;
+    float m_angle;
+    float m_angleBase;
+#ifdef KWIN_HAVE_XRENDER_COMPOSITING
+    QSize m_size[2];
+#endif
+    QAction* m_action;
+    QScopedPointer<GLTexture> m_cursorTexture;
+    Qt::KeyboardModifiers m_modifiers;
+    bool m_inited;
+    bool m_valid;
+    GLShader* m_shader;
+    float m_prevX, m_prevY;
+};
+
+} // namespace
+
+#endif
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/mousepos/mousepos.kcfg kwin-lowlatency/effects/mousepos/mousepos.kcfg
--- kwin-5.16.2/effects/mousepos/mousepos.kcfg	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/effects/mousepos/mousepos.kcfg	2019-06-25 23:16:16.670094258 +0300
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<kcfg xmlns="http://www.kde.org/standards/kcfg/1.0"
+      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+      xsi:schemaLocation="http://www.kde.org/standards/kcfg/1.0
+                          http://www.kde.org/standards/kcfg/1.0/kcfg.xsd" >
+    <kcfgfile arg="true"/>
+    <group name="Effect-MousePos">
+        <entry name="MotionBlur" type="Bool">
+            <default>false</default>
+        </entry>
+    </group>
+</kcfg>
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/presentwindows/presentwindows_config.ui kwin-lowlatency/effects/presentwindows/presentwindows_config.ui
--- kwin-5.16.2/effects/presentwindows/presentwindows_config.ui	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/effects/presentwindows/presentwindows_config.ui	2019-06-25 23:16:16.671094257 +0300
@@ -164,6 +164,11 @@
           <string>(Un-)Minimize window</string>
          </property>
         </item>
+        <item>
+         <property name="text">
+          <string>Close window</string>
+         </property>
+        </item>
        </widget>
       </item>
       <item row="1" column="0">
@@ -208,6 +213,11 @@
           <string>(Un-)Minimize window</string>
          </property>
         </item>
+        <item>
+         <property name="text">
+          <string>Close window</string>
+         </property>
+        </item>
        </widget>
       </item>
       <item row="2" column="0">
@@ -252,6 +262,11 @@
           <string>(Un-)Minimize window</string>
          </property>
         </item>
+        <item>
+         <property name="text">
+          <string>Close window</string>
+         </property>
+        </item>
        </widget>
       </item>
      </layout>
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/presentwindows/presentwindows.cpp kwin-lowlatency/effects/presentwindows/presentwindows.cpp
--- kwin-5.16.2/effects/presentwindows/presentwindows.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/effects/presentwindows/presentwindows.cpp	2019-06-25 23:16:16.671094257 +0300
@@ -719,6 +719,11 @@
                 m_highlightedWindow->minimize();
         }
         break;
+    case WindowCloseAction:
+        if (m_highlightedWindow) {
+            m_highlightedWindow->closeWindow();
+        }
+        break;
     default:
         break;
     }
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/presentwindows/presentwindows.h kwin-lowlatency/effects/presentwindows/presentwindows.h
--- kwin-5.16.2/effects/presentwindows/presentwindows.h	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/effects/presentwindows/presentwindows.h	2019-06-25 23:16:16.671094257 +0300
@@ -149,7 +149,8 @@
         WindowExitAction = 2, // Deactivates the effect without activating new window
         WindowToCurrentDesktopAction = 3, // Brings window to current desktop
         WindowToAllDesktopsAction = 4, // Brings window to all desktops
-        WindowMinimizeAction = 5 // Minimize the window
+        WindowMinimizeAction = 5, // Minimize the window
+        WindowCloseAction = 6 // Closes the window
     };
     enum DesktopMouseAction {
         DesktopNoAction = 0, // nothing
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/shaders.qrc kwin-lowlatency/effects/shaders.qrc
--- kwin-5.16.2/effects/shaders.qrc	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/effects/shaders.qrc	2019-06-25 23:16:16.672094255 +0300
@@ -6,6 +6,8 @@
   <file alias="cylinder.vert">cube/data/1.10/cylinder.vert</file>
   <file alias="sphere.vert">cube/data/1.10/sphere.vert</file>
   <file alias="invert.frag">invert/data/1.10/invert.frag</file>
+  <file alias="motion.vert">mousepos/data/1.10/motion.vert</file>
+  <file alias="motion.frag">mousepos/data/1.10/motion.frag</file>
   <file alias="lookingglass.frag">lookingglass/data/1.10/lookingglass.frag</file>
   <file alias="blinking-startup-fragment.glsl">startupfeedback/data/1.10/blinking-startup-fragment.glsl</file>
 </qresource>
@@ -16,6 +18,8 @@
   <file alias="cylinder.vert">cube/data/1.40/cylinder.vert</file>
   <file alias="sphere.vert">cube/data/1.40/sphere.vert</file>
   <file alias="invert.frag">invert/data/1.40/invert.frag</file>
+  <file alias="motion.vert">mousepos/data/1.40/motion.vert</file>
+  <file alias="motion.frag">mousepos/data/1.40/motion.frag</file>
   <file alias="lookingglass.frag">lookingglass/data/1.40/lookingglass.frag</file>
   <file alias="blinking-startup-fragment.glsl">startupfeedback/data/1.40/blinking-startup-fragment.glsl</file>
 </qresource>
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/zoom/zoom.cpp kwin-lowlatency/effects/zoom/zoom.cpp
--- kwin-5.16.2/effects/zoom/zoom.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/effects/zoom/zoom.cpp	2019-06-25 23:16:16.676094248 +0300
@@ -45,6 +45,7 @@
 ZoomEffect::ZoomEffect()
     : Effect()
     , zoom(1)
+    , previous_zoom(1)
     , target_zoom(1)
     , polling(false)
     , zoomFactor(1.25)
@@ -253,6 +254,7 @@
 
 void ZoomEffect::prePaintScreen(ScreenPrePaintData& data, int time)
 {
+    previous_zoom=zoom;
     if (zoom != target_zoom) {
         const float zoomDist = qAbs(target_zoom - source_zoom);
         if (target_zoom > zoom)
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects/zoom/zoom.h kwin-lowlatency/effects/zoom/zoom.h
--- kwin-5.16.2/effects/zoom/zoom.h	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/effects/zoom/zoom.h	2019-06-25 23:16:16.676094248 +0300
@@ -100,6 +100,7 @@
     void moveZoom(int x, int y);
 private:
     double zoom;
+    double previous_zoom;
     double target_zoom;
     double source_zoom;
     bool polling; // Mouse polling
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/effects.cpp kwin-lowlatency/effects.cpp
--- kwin-5.16.2/effects.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/effects.cpp	2019-06-25 23:16:16.659094276 +0300
@@ -642,6 +642,7 @@
     }
     const bool activeChanged = (e == nullptr || fullscreen_effect == nullptr);
     fullscreen_effect = e;
+    m_compositor->checkUnredirect();
     emit activeFullScreenEffectChanged();
     if (activeChanged) {
         emit hasActiveFullScreenEffectChanged();
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/geometry.cpp kwin-lowlatency/geometry.cpp
--- kwin-5.16.2/geometry.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/geometry.cpp	2019-06-25 23:16:16.677094247 +0300
@@ -86,6 +86,9 @@
     if (effects) {
         static_cast<EffectsHandlerImpl*>(effects)->desktopResized(geom.size());
     }
+
+    //Update the shape of the overlay window to fix redrawing of unredirected windows. bug#305781
+    m_compositor->checkUnredirect(true);
 }
 
 void Workspace::saveOldScreenSizes()
@@ -2106,6 +2109,10 @@
     updateWindowRules(Rules::Position);
     screens()->setCurrent(this);
     workspace()->updateStackingOrder();
+    if (Compositor::isCreated()) {
+        // TODO: move out of geometry.cpp, is this really needed here?
+        Compositor::self()->checkUnredirect();
+    }
     // client itself is not damaged
     addRepaintDuringGeometryUpdates();
     updateGeometryBeforeUpdateBlocking();
@@ -3210,9 +3217,11 @@
         syncRequest.timeout->start(250);
         sendSyncRequest();
     } else {                            // for clients not supporting the XSYNC protocol, we
-        syncRequest.isPending = true;   // limit the resizes to 30Hz to take pointless load from X11
-        syncRequest.timeout->start(33); // and the client, the mouse is still moved at full speed
+        //syncRequest.isPending = true; // limit the resizes to 30Hz to take pointless load from X11
+        performMoveResize();
+        //syncRequest.timeout->start(1);// and the client, the mouse is still moved at full speed
     }                                   // and no human can control faster resizes anyway
+                                        // no, don't. Windows can do 60Hz resizes, so why don't we?
     const QRect &moveResizeGeom = moveResizeGeometry();
     m_client.setGeometry(0, 0, moveResizeGeom.width() - (borderLeft() + borderRight()), moveResizeGeom.height() - (borderTop() + borderBottom()));
 }
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/HACKING.md kwin-lowlatency/HACKING.md
--- kwin-5.16.2/HACKING.md	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/HACKING.md	2019-06-25 23:16:16.630094325 +0300
@@ -21,13 +21,16 @@
 
 To start a nested KWin Wayland use:
 
-    cd build
-    cd bin
-    QT_PLUGIN_PATH=`pwd` dbus-run-session ./kwin_wayland --xwayland --socket=wayland-1
+```
+cd build
+QT_PLUGIN_PATH="$PWD/bin" dbus-run-session ./bin/kwin_wayland --xwayland --socket=wayland-1
+```
 
 The socket option is not required if KWin is started from an X11 session. On Wayland of course a socket not matching the session's socket must be chosen. To show windows in the nested KWin adjust the environment variables DISPLAY (for X11 windows) and WAYLAND_DISPLAY (for Wayland windows). Alternatively it's possible to pass applications to launch as command line arguments to kwin_wayland command. E.g.
 
-    QT_PLUGIN_PATH=`pwd` dbus-run-session ./kwin_wayland --xwayland --socket=wayland-1 konsole
+```
+QT_PLUGIN_PATH="$PWD/bin" dbus-run-session ./bin/kwin_wayland --xwayland --socket=wayland-1 konsole
+```
 
 Will start a konsole in the nested KWin.
 
@@ -47,9 +50,10 @@
 
 KWin for the X11 windowing system cannot be tested with a nested Wayland setup. Instead the common way is to run KWin and replace the existing window manager of the X session:
 
-    cd build
-    cd bin
-    QT_PLUGIN_PATH=`pwd` ./kwin_x11 --replace
+```
+cd build
+QT_PLUGIN_PATH="$PWD/bin" ./bin/kwin_x11 --replace
+```
 
 In this case also the current DBus session should be used and dbus-run-session should not be used. Of course it's only possible to start kwin_x11 in an X session. On Wayland kwin_x11 will refuse to start.
 
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/kcmkwin/kwincompositing/compositing.cpp kwin-lowlatency/kcmkwin/kwincompositing/compositing.cpp
--- kwin-5.16.2/kcmkwin/kwincompositing/compositing.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/kcmkwin/kwincompositing/compositing.cpp	2019-06-25 23:16:16.679094243 +0300
@@ -41,6 +41,7 @@
     , m_windowThumbnail(0)
     , m_glScaleFilter(0)
     , m_xrScaleFilter(false)
+    , m_unredirectFullscreen(false)
     , m_glSwapStrategy(0)
     , m_compositingType(0)
     , m_compositingEnabled(true)
@@ -48,6 +49,10 @@
     , m_openGLPlatformInterfaceModel(new OpenGLPlatformInterfaceModel(this))
     , m_openGLPlatformInterface(0)
     , m_windowsBlockCompositing(true)
+    , m_animationCurve(2)
+    , m_latencyControl(1)
+    , m_maxLatency(8)
+    , m_minLatency(0)
     , m_compositingInterface(new OrgKdeKwinCompositingInterface(QStringLiteral("org.kde.KWin"), QStringLiteral("/Compositor"), QDBusConnection::sessionBus(), this))
 {
     reset();
@@ -55,11 +60,16 @@
     connect(this, &Compositing::windowThumbnailChanged,      this, &Compositing::changed);
     connect(this, &Compositing::glScaleFilterChanged,        this, &Compositing::changed);
     connect(this, &Compositing::xrScaleFilterChanged,        this, &Compositing::changed);
+    connect(this, &Compositing::unredirectFullscreenChanged, this, &Compositing::changed);
     connect(this, &Compositing::glSwapStrategyChanged,       this, &Compositing::changed);
     connect(this, &Compositing::compositingTypeChanged,      this, &Compositing::changed);
     connect(this, &Compositing::compositingEnabledChanged,   this, &Compositing::changed);
     connect(this, &Compositing::openGLPlatformInterfaceChanged, this, &Compositing::changed);
     connect(this, &Compositing::windowsBlockCompositingChanged, this, &Compositing::changed);
+    connect(this, &Compositing::animationCurveChanged,          this, &Compositing::changed);
+    connect(this, &Compositing::latencyControlChanged,          this, &Compositing::changed);
+    connect(this, &Compositing::maxLatencyChanged,              this, &Compositing::changed);
+    connect(this, &Compositing::minLatencyChanged,              this, &Compositing::changed);
 
     connect(this, &Compositing::changed, [this]{
         m_changed = true;
@@ -73,6 +83,7 @@
     setWindowThumbnail(kwinConfig.readEntry("HiddenPreviews", 5) - 4);
     setGlScaleFilter(kwinConfig.readEntry("GLTextureFilter", 2));
     setXrScaleFilter(kwinConfig.readEntry("XRenderSmoothScale", false));
+    setUnredirectFullscreen(kwinConfig.readEntry("UnredirectFullscreen", false));
     setCompositingEnabled(kwinConfig.readEntry("Enabled", true));
 
     auto swapStrategy = [&kwinConfig]() {
@@ -114,6 +125,11 @@
 
     setWindowsBlockCompositing(kwinConfig.readEntry("WindowsBlockCompositing", true));
 
+    setAnimationCurve(kwinConfig.readEntry("AnimationCurve",2));
+    setLatencyControl(kwinConfig.readEntry("LatencyControl",1));
+    setMaxLatency(kwinConfig.readEntry("MaxLatency",8));
+    setMinLatency(kwinConfig.readEntry("MinLatency",0));
+
     m_changed = false;
 }
 
@@ -123,11 +139,16 @@
     setWindowThumbnail(1);
     setGlScaleFilter(2);
     setXrScaleFilter(false);
+    setUnredirectFullscreen(false);
     setGlSwapStrategy(1);
     setCompositingType(CompositingType::OPENGL20_INDEX);
     const QModelIndex index = m_openGLPlatformInterfaceModel->indexForKey(QStringLiteral("glx"));
     setOpenGLPlatformInterface(index.isValid() ? index.row() : 0);
     setWindowsBlockCompositing(true);
+    setAnimationCurve(2);
+    setLatencyControl(1);
+    setMaxLatency(8);
+    setMinLatency(0);
     m_changed = true;
 }
 
@@ -183,6 +204,11 @@
     return m_xrScaleFilter;
 }
 
+bool Compositing::unredirectFullscreen() const
+{
+    return m_unredirectFullscreen;
+}
+
 int Compositing::glSwapStrategy() const
 {
     return m_glSwapStrategy;
@@ -225,6 +251,15 @@
     emit glSwapStrategyChanged(strategy);
 }
 
+void Compositing::setUnredirectFullscreen(bool unredirect)
+{
+    if (unredirect == m_unredirectFullscreen) {
+        return;
+    }
+    m_unredirectFullscreen = unredirect;
+    emit unredirectFullscreenChanged(unredirect);
+}
+
 void Compositing::setWindowThumbnail(int index)
 {
     if (index == m_windowThumbnail) {
@@ -272,6 +307,7 @@
     kwinConfig.writeEntry("HiddenPreviews", windowThumbnail() + 4);
     kwinConfig.writeEntry("GLTextureFilter", glScaleFilter());
     kwinConfig.writeEntry("XRenderSmoothScale", xrScaleFilter());
+    kwinConfig.writeEntry("UnredirectFullscreen", unredirectFullscreen());
     if (!compositingRequired()) {
         kwinConfig.writeEntry("Enabled", compositingEnabled());
     }
@@ -312,6 +348,10 @@
     if (!compositingRequired()) {
         kwinConfig.writeEntry("WindowsBlockCompositing", windowsBlockCompositing());
     }
+    kwinConfig.writeEntry("AnimationCurve",animationCurve());
+    kwinConfig.writeEntry("LatencyControl",latencyControl());
+    kwinConfig.writeEntry("MaxLatency",maxLatency());
+    kwinConfig.writeEntry("MinLatency",minLatency());
     kwinConfig.sync();
 
     if (m_changed) {
@@ -360,6 +400,62 @@
     emit windowsBlockCompositingChanged(set);
 }
 
+int Compositing::animationCurve() const
+{
+    return m_animationCurve;
+}
+
+int Compositing::latencyControl() const
+{
+    return m_latencyControl;
+}
+
+int Compositing::maxLatency() const
+{
+    return m_maxLatency;
+}
+
+int Compositing::minLatency() const
+{
+    return m_minLatency;
+}
+
+void Compositing::setAnimationCurve(int val)
+{
+    if (m_animationCurve == val) {
+        return;
+    }
+    m_animationCurve = val;
+    emit animationCurveChanged(val);
+}
+
+void Compositing::setLatencyControl(int val)
+{
+    if (m_latencyControl == val) {
+        return;
+    }
+    m_latencyControl = val;
+    emit latencyControlChanged(val);
+}
+
+void Compositing::setMaxLatency(int val)
+{
+    if (m_maxLatency == val) {
+        return;
+    }
+    m_maxLatency = val;
+    emit maxLatencyChanged(val);
+}
+
+void Compositing::setMinLatency(int val)
+{
+    if (m_minLatency == val) {
+        return;
+    }
+    m_minLatency = val;
+    emit minLatencyChanged(val);
+}
+
 bool Compositing::compositingRequired() const
 {
     return m_compositingInterface->platformRequiresCompositing();
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/kcmkwin/kwincompositing/compositing.h kwin-lowlatency/kcmkwin/kwincompositing/compositing.h
--- kwin-5.16.2/kcmkwin/kwincompositing/compositing.h	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/kcmkwin/kwincompositing/compositing.h	2019-06-25 23:16:16.679094243 +0300
@@ -40,12 +40,17 @@
     Q_PROPERTY(int windowThumbnail READ windowThumbnail WRITE setWindowThumbnail NOTIFY windowThumbnailChanged)
     Q_PROPERTY(int glScaleFilter READ glScaleFilter WRITE setGlScaleFilter NOTIFY glScaleFilterChanged)
     Q_PROPERTY(bool xrScaleFilter READ xrScaleFilter WRITE setXrScaleFilter NOTIFY xrScaleFilterChanged)
+    Q_PROPERTY(bool unredirectFullscreen READ unredirectFullscreen WRITE setUnredirectFullscreen NOTIFY unredirectFullscreenChanged)
     Q_PROPERTY(int glSwapStrategy READ glSwapStrategy WRITE setGlSwapStrategy NOTIFY glSwapStrategyChanged)
     Q_PROPERTY(int compositingType READ compositingType WRITE setCompositingType NOTIFY compositingTypeChanged)
     Q_PROPERTY(bool compositingEnabled READ compositingEnabled WRITE setCompositingEnabled NOTIFY compositingEnabledChanged)
     Q_PROPERTY(KWin::Compositing::OpenGLPlatformInterfaceModel *openGLPlatformInterfaceModel READ openGLPlatformInterfaceModel CONSTANT)
     Q_PROPERTY(int openGLPlatformInterface READ openGLPlatformInterface WRITE setOpenGLPlatformInterface NOTIFY openGLPlatformInterfaceChanged)
     Q_PROPERTY(bool windowsBlockCompositing READ windowsBlockCompositing WRITE setWindowsBlockCompositing NOTIFY windowsBlockCompositingChanged)
+    Q_PROPERTY(int animationCurve READ animationCurve WRITE setAnimationCurve NOTIFY animationCurveChanged)
+    Q_PROPERTY(int latencyControl READ latencyControl WRITE setLatencyControl NOTIFY latencyControlChanged)
+    Q_PROPERTY(int maxLatency READ maxLatency WRITE setMaxLatency NOTIFY maxLatencyChanged)
+    Q_PROPERTY(int minLatency READ minLatency WRITE setMinLatency NOTIFY minLatencyChanged)
     Q_PROPERTY(bool compositingRequired READ compositingRequired CONSTANT)
 public:
     explicit Compositing(QObject *parent = 0);
@@ -57,11 +62,16 @@
     int windowThumbnail() const;
     int glScaleFilter() const;
     bool xrScaleFilter() const;
+    bool unredirectFullscreen() const;
     int glSwapStrategy() const;
     int compositingType() const;
     bool compositingEnabled() const;
     int openGLPlatformInterface() const;
     bool windowsBlockCompositing() const;
+    int animationCurve() const;
+    int latencyControl() const;
+    int maxLatency() const;
+    int minLatency() const;
     bool compositingRequired() const;
 
     OpenGLPlatformInterfaceModel *openGLPlatformInterfaceModel() const;
@@ -70,12 +80,16 @@
     void setWindowThumbnail(int index);
     void setGlScaleFilter(int index);
     void setXrScaleFilter(bool filter);
+    void setUnredirectFullscreen(bool unredirect);
     void setGlSwapStrategy(int strategy);
     void setCompositingType(int index);
-    void setCompositingEnabled(bool enalbed);
+    void setCompositingEnabled(bool enabled);
     void setOpenGLPlatformInterface(int interface);
     void setWindowsBlockCompositing(bool set);
-
+    void setAnimationCurve(int curve);
+    void setLatencyControl(int index);
+    void setMaxLatency(int val);
+    void setMinLatency(int val);
     void save();
 
 public Q_SLOTS:
@@ -88,17 +102,23 @@
     void windowThumbnailChanged(int);
     void glScaleFilterChanged(int);
     void xrScaleFilterChanged(int);
+    void unredirectFullscreenChanged(bool);
     void glSwapStrategyChanged(int);
     void compositingTypeChanged(int);
     void compositingEnabledChanged(bool);
     void openGLPlatformInterfaceChanged(int);
     void windowsBlockCompositingChanged(bool);
+    void animationCurveChanged(int);
+    void latencyControlChanged(int);
+    void maxLatencyChanged(int);
+    void minLatencyChanged(int);
 
 private:
     int m_animationSpeed;
     int m_windowThumbnail;
     int m_glScaleFilter;
     bool m_xrScaleFilter;
+    bool m_unredirectFullscreen;
     int m_glSwapStrategy;
     int m_compositingType;
     bool m_compositingEnabled;
@@ -106,6 +126,10 @@
     OpenGLPlatformInterfaceModel *m_openGLPlatformInterfaceModel;
     int m_openGLPlatformInterface;
     bool m_windowsBlockCompositing;
+    int m_animationCurve;
+    int m_latencyControl;
+    int m_maxLatency;
+    int m_minLatency;
     bool m_windowsBlockingCompositing;
     OrgKdeKwinCompositingInterface *m_compositingInterface;
 };
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/kcmkwin/kwincompositing/compositing.ui kwin-lowlatency/kcmkwin/kwincompositing/compositing.ui
--- kwin-5.16.2/kcmkwin/kwincompositing/compositing.ui	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/kcmkwin/kwincompositing/compositing.ui	2019-06-25 23:16:16.679094243 +0300
@@ -6,8 +6,8 @@
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>462</width>
-    <height>349</height>
+    <width>497</width>
+    <height>552</height>
    </rect>
   </property>
   <layout class="QFormLayout" name="formLayout">
@@ -21,16 +21,32 @@
        <property name="visible">
         <bool>false</bool>
        </property>
-       <property name="text">
+       <property name="text" stdset="0">
         <string>OpenGL compositing (the default) has crashed KWin in the past.
 This was most likely due to a driver bug.
 If you think that you have meanwhile upgraded to a stable driver,
 you can reset this protection but be aware that this might result in an immediate crash!
 Alternatively, you might want to use the XRender backend instead.</string>
        </property>
+       <property name="wordWrap" stdset="0">
+        <bool>true</bool>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="KMessageWidget" name="unredirectInformation">
+       <property name="visible">
+        <bool>false</bool>
+       </property>
+       <property name="text">
+        <string>Having full screen windows bypass the compositor is not supported on every hardware.</string>
+       </property>
        <property name="wordWrap">
         <bool>true</bool>
        </property>
+       <property name="messageType">
+        <enum>KMessageWidget::Information</enum>
+       </property>
       </widget>
      </item>
      <item>
@@ -38,10 +54,10 @@
        <property name="visible">
         <bool>false</bool>
        </property>
-       <property name="text">
+       <property name="text" stdset="0">
         <string>Scale method &quot;Accurate&quot; is not supported by all hardware and can cause performance regressions and rendering artifacts.</string>
        </property>
-       <property name="wordWrap">
+       <property name="wordWrap" stdset="0">
         <bool>true</bool>
        </property>
       </widget>
@@ -51,7 +67,7 @@
        <property name="visible">
         <bool>false</bool>
        </property>
-       <property name="wordWrap">
+       <property name="wordWrap" stdset="0">
         <bool>true</bool>
        </property>
       </widget>
@@ -61,10 +77,10 @@
        <property name="visible">
         <bool>false</bool>
        </property>
-       <property name="text">
+       <property name="text" stdset="0">
         <string>Keeping the window thumbnail always interferes with the minimized state of windows. This can result in windows not suspending their work when minimized.</string>
        </property>
-       <property name="wordWrap">
+       <property name="wordWrap" stdset="0">
         <bool>true</bool>
        </property>
       </widget>
@@ -281,6 +297,115 @@
      </property>
     </widget>
    </item>
+   <item row="13" column="1">
+    <widget class="QCheckBox" name="unredirectFullscreen">
+     <property name="text">
+      <string>Suspend compositor for full screen windows</string>
+     </property>
+    </widget>
+   </item>
+   <item row="14" column="0" colspan="2">
+    <widget class="Line" name="line_3">
+     <property name="orientation">
+      <enum>Qt::Horizontal</enum>
+     </property>
+    </widget>
+   </item>
+   <item row="15" column="0">
+    <widget class="QLabel" name="label_7">
+     <property name="text">
+      <string>Animation curve:</string>
+     </property>
+    </widget>
+   </item>
+   <item row="15" column="1">
+    <widget class="QComboBox" name="animationCurve">
+     <item>
+      <property name="text">
+       <string>Linear</string>
+      </property>
+     </item>
+     <item>
+      <property name="text">
+       <string>Quadratic</string>
+      </property>
+     </item>
+     <item>
+      <property name="text">
+       <string>Sine</string>
+      </property>
+     </item>
+    </widget>
+   </item>
+   <item row="16" column="0">
+    <widget class="QLabel" name="label_8">
+     <property name="text">
+      <string>Latency/stutter control:</string>
+     </property>
+    </widget>
+   </item>
+   <item row="16" column="1">
+    <widget class="QComboBox" name="latencyControl">
+     <item>
+      <property name="text">
+       <string>Favor responsiveness</string>
+      </property>
+     </item>
+     <item>
+      <property name="text">
+       <string>Balanced</string>
+      </property>
+     </item>
+     <item>
+      <property name="text">
+       <string>Favor low latency</string>
+      </property>
+     </item>
+     <item>
+      <property name="text">
+       <string>Aggressively favor low latency</string>
+      </property>
+     </item>
+    </widget>
+   </item>
+   <item row="17" column="0">
+    <widget class="QLabel" name="label_9">
+     <property name="text">
+      <string>Maximum latency reduction:</string>
+     </property>
+    </widget>
+   </item>
+   <item row="17" column="1">
+    <widget class="QSpinBox" name="maxLatency">
+     <property name="maximum">
+      <number>8</number>
+     </property>
+    </widget>
+   </item>
+   <item row="18" column="0">
+    <widget class="QLabel" name="label_10">
+     <property name="text">
+      <string>Minimum latency reduction:</string>
+     </property>
+    </widget>
+   </item>
+   <item row="18" column="1">
+    <widget class="QSpinBox" name="minLatency">
+     <property name="maximum">
+      <number>8</number>
+     </property>
+    </widget>
+   </item>
+   <item row="19" column="1">
+    <widget class="QLabel" name="label_11">
+     <property name="text">
+      <string>(units in milliseconds)</string>
+     </property>
+     <property name="alignment">
+      <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+     </property>
+    </widget>
+   </item>
   </layout>
  </widget>
  <customwidgets>
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/kcmkwin/kwincompositing/main.cpp kwin-lowlatency/kcmkwin/kwincompositing/main.cpp
--- kwin-5.16.2/kcmkwin/kwincompositing/main.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/kcmkwin/kwincompositing/main.cpp	2019-06-25 23:16:16.680094242 +0300
@@ -25,6 +25,7 @@
 #include <QAction>
 #include <QApplication>
 #include <QLayout>
+#include <QSpinBox>
 
 #include <kcmodule.h>
 #include <kservice.h>
@@ -59,6 +60,7 @@
     m_form.scaleWarning->setIcon(QIcon::fromTheme(QStringLiteral("dialog-warning")));
     m_form.tearingWarning->setIcon(QIcon::fromTheme(QStringLiteral("dialog-warning")));
     m_form.windowThumbnailWarning->setIcon(QIcon::fromTheme(QStringLiteral("dialog-warning")));
+    m_form.unredirectInformation->setIcon(QIcon::fromTheme(QStringLiteral("dialog-information")));
 
     m_form.compositingEnabled->setVisible(!m_compositing->compositingRequired());
     m_form.windowsBlockCompositing->setVisible(!m_compositing->compositingRequired());
@@ -70,6 +72,7 @@
 {
     using namespace KWin::Compositing;
     auto currentIndexChangedSignal = static_cast<void(QComboBox::*)(int)>(&QComboBox::currentIndexChanged);
+    auto valueChangedSignal = static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged);
 
     connect(m_compositing, &Compositing::changed, this, static_cast<void(KCModule::*)()>(&KWinCompositingSettings::changed));
 
@@ -152,6 +155,40 @@
     connect(m_compositing, &Compositing::windowsBlockCompositingChanged, m_form.windowsBlockCompositing, &QCheckBox::setChecked);
     connect(m_form.windowsBlockCompositing, &QCheckBox::toggled, m_compositing, &Compositing::setWindowsBlockCompositing);
 
+    // unredirect fullscreen
+    m_form.unredirectFullscreen->setChecked(m_compositing->unredirectFullscreen());
+    connect(m_compositing, &Compositing::unredirectFullscreenChanged, m_form.unredirectFullscreen, &QCheckBox::setChecked);
+    connect(m_form.unredirectFullscreen, &QCheckBox::toggled, m_compositing, &Compositing::setUnredirectFullscreen);
+    connect(m_form.unredirectFullscreen, &QCheckBox::toggled,
+        [this](bool enabled) {
+            if (enabled) {
+                m_form.unredirectInformation->animatedShow();
+            } else {
+                m_form.unredirectInformation->animatedHide();
+            }
+        }
+    );
+
+    // animation curve
+    m_form.animationCurve->setCurrentIndex(m_compositing->animationCurve());
+    connect(m_compositing, &Compositing::animationCurveChanged, m_form.animationCurve, &QComboBox::setCurrentIndex);
+    connect(m_form.animationCurve, currentIndexChangedSignal, m_compositing, &Compositing::setAnimationCurve);
+
+    // latency control
+    m_form.latencyControl->setCurrentIndex(m_compositing->latencyControl());
+    connect(m_compositing, &Compositing::latencyControlChanged, m_form.latencyControl, &QComboBox::setCurrentIndex);
+    connect(m_form.latencyControl, currentIndexChangedSignal, m_compositing, &Compositing::setLatencyControl);
+
+    // max latency
+    m_form.maxLatency->setValue(m_compositing->maxLatency());
+    connect(m_compositing, &Compositing::maxLatencyChanged, m_form.maxLatency, &QSpinBox::setValue);
+    connect(m_form.maxLatency, valueChangedSignal, m_compositing, &Compositing::setMaxLatency);
+
+    // min latency
+    m_form.minLatency->setValue(m_compositing->minLatency());
+    connect(m_compositing, &Compositing::minLatencyChanged, m_form.minLatency, &QSpinBox::setValue);
+    connect(m_form.minLatency, valueChangedSignal, m_compositing, &Compositing::setMinLatency);
+
     // compositing type
     CompositingType *type = new CompositingType(this);
     m_form.type->setModel(type);
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/kwin.kcfg kwin-lowlatency/kwin.kcfg
--- kwin-5.16.2/kwin.kcfg	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/kwin.kcfg	2019-06-25 23:16:16.688094229 +0300
@@ -251,6 +251,9 @@
             <min>4</min>
             <max>6</max>
         </entry>
+        <entry name="UnredirectFullscreen" type="Bool">
+            <default>false</default>
+        </entry>
         <entry name="AnimationSpeed" type="Int">
             <default>3</default>
             <min>0</min>
@@ -262,6 +265,26 @@
         <entry name="WindowsBlockCompositing" type="Bool">
             <default>true</default>
         </entry>
+        <entry name="AnimationCurve" type="Int">
+            <default>2</default>
+            <min>0</min>
+            <max>2</max>
+        </entry>
+        <entry name="LatencyControl" type="Int">
+            <default>1</default>
+            <min>0</min>
+            <max>3</max>
+        </entry>
+        <entry name="MaxLatency" type="Int">
+            <default>8</default>
+            <min>0</min>
+            <max>8</max>
+        </entry>
+        <entry name="MinLatency" type="Int">
+            <default>0</default>
+            <min>0</min>
+            <max>8</max>
+        </entry>
     </group>
     <group name="TabBox">
         <entry name="ShowDelay" type="Bool">
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/layers.cpp kwin-lowlatency/layers.cpp
--- kwin-5.16.2/layers.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/layers.cpp	2019-06-25 23:16:16.688094229 +0300
@@ -733,6 +733,9 @@
     if (m_xStackingDirty) {
         const_cast<Workspace*>(this)->updateXStackingOrder();
     }
+    if (m_compositor) {
+        const_cast< Workspace* >(this)->m_compositor->checkUnredirect();
+    }
     return x_stacking;
 }
 
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/options.cpp kwin-lowlatency/options.cpp
--- kwin-5.16.2/options.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/options.cpp	2019-06-25 23:16:16.692094222 +0300
@@ -114,6 +114,7 @@
     , m_useCompositing(Options::defaultUseCompositing())
     , m_compositingInitialized(Options::defaultCompositingInitialized())
     , m_hiddenPreviews(Options::defaultHiddenPreviews())
+    , m_unredirectFullscreen(Options::defaultUnredirectFullscreen())
     , m_glSmoothScale(Options::defaultGlSmoothScale())
     , m_xrenderSmoothScale(Options::defaultXrenderSmoothScale())
     , m_maxFpsInterval(Options::defaultMaxFpsInterval())
@@ -125,6 +126,10 @@
     , m_glPreferBufferSwap(Options::defaultGlPreferBufferSwap())
     , m_glPlatformInterface(Options::defaultGlPlatformInterface())
     , m_windowsBlockCompositing(true)
+    , m_animationCurve(Options::defaultAnimationCurve())
+    , m_latencyControl(Options::defaultLatencyControl())
+    , m_maxLatency(Options::defaultMaxLatency())
+    , m_minLatency(Options::defaultMinLatency())
     , OpTitlebarDblClick(Options::defaultOperationTitlebarDblClick())
     , CmdActiveTitlebar1(Options::defaultCommandActiveTitlebar1())
     , CmdActiveTitlebar2(Options::defaultCommandActiveTitlebar2())
@@ -633,6 +638,20 @@
     emit hiddenPreviewsChanged();
 }
 
+void Options::setUnredirectFullscreen(bool unredirectFullscreen)
+{
+    //if (GLPlatform::instance()->driver() == Driver_Intel)
+        //unredirectFullscreen = false; // bug #252817
+    if (m_unredirectFullscreen == unredirectFullscreen) {
+        return;
+    }
+    //if (GLPlatform::instance()->driver() == Driver_Intel) { // write back the value
+        //KConfigGroup(m_settings->config(), "Compositing").writeEntry("UnredirectFullscreen", false);
+    //}
+    m_unredirectFullscreen = unredirectFullscreen;
+    emit unredirectFullscreenChanged();
+}
+
 void Options::setGlSmoothScale(int glSmoothScale)
 {
     if (m_glSmoothScale == glSmoothScale) {
@@ -714,6 +733,38 @@
     emit windowsBlockCompositingChanged();
 }
 
+void Options::setAnimationCurve(int val) {
+  if (m_animationCurve == val) {
+    return;
+  }
+  m_animationCurve = val;
+  emit animationCurveChanged();
+}
+
+void Options::setLatencyControl(int val) {
+  if (m_latencyControl == val) {
+    return;
+  }
+  m_latencyControl = val;
+  emit latencyControlChanged();
+}
+
+void Options::setMaxLatency(int val) {
+  if (m_maxLatency == val) {
+    return;
+  }
+  m_maxLatency = val;
+  emit maxLatencyChanged();
+}
+
+void Options::setMinLatency(int val) {
+  if (m_minLatency == val) {
+    return;
+  }
+  m_minLatency = val;
+  emit minLatencyChanged();
+}
+
 void Options::setGlPreferBufferSwap(char glPreferBufferSwap)
 {
     if (glPreferBufferSwap == 'a') {
@@ -888,6 +939,10 @@
     setElectricBorderCornerRatio(m_settings->electricBorderCornerRatio());
     setWindowsBlockCompositing(m_settings->windowsBlockCompositing());
 
+    setAnimationCurve(m_settings->animationCurve());
+    setLatencyControl(m_settings->latencyControl());
+    setMaxLatency(m_settings->maxLatency());
+    setMinLatency(m_settings->minLatency());
 }
 
 bool Options::loadCompositingConfig (bool force)
@@ -991,7 +1046,8 @@
         previews = HiddenPreviewsAlways;
     setHiddenPreviews(previews);
 
-    // TOOD: add setter
+    setUnredirectFullscreen(config.readEntry("UnredirectFullscreen", Options::defaultUnredirectFullscreen()));
+    // TODO: add setter
     animationSpeed = qBound(0, config.readEntry("AnimationSpeed", Options::defaultAnimationSpeed()), 6);
 
     auto interfaceToKey = [](OpenGLPlatformInterface interface) {
@@ -1145,4 +1201,9 @@
     return m_useCompositing || kwinApp()->platform()->requiresCompositing();
 }
 
+bool Options::isUnredirectFullscreen() const
+{
+    return m_unredirectFullscreen && !kwinApp()->platform()->requiresCompositing();
+}
+
 } // namespace
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/options.h kwin-lowlatency/options.h
--- kwin-5.16.2/options.h	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/options.h	2019-06-25 23:16:16.692094222 +0300
@@ -169,6 +169,7 @@
     Q_PROPERTY(bool useCompositing READ isUseCompositing WRITE setUseCompositing NOTIFY useCompositingChanged)
     Q_PROPERTY(bool compositingInitialized READ isCompositingInitialized WRITE setCompositingInitialized NOTIFY compositingInitializedChanged)
     Q_PROPERTY(int hiddenPreviews READ hiddenPreviews WRITE setHiddenPreviews NOTIFY hiddenPreviewsChanged)
+    Q_PROPERTY(bool unredirectFullscreen READ isUnredirectFullscreen WRITE setUnredirectFullscreen NOTIFY unredirectFullscreenChanged)
     /**
      * 0 = no, 1 = yes when transformed,
      * 2 = try trilinear when transformed; else 1,
@@ -566,6 +567,7 @@
     HiddenPreviews hiddenPreviews() const {
         return m_hiddenPreviews;
     }
+    bool isUnredirectFullscreen() const;
     // OpenGL
     // 0 = no, 1 = yes when transformed,
     // 2 = try trilinear when transformed; else 1,
@@ -610,6 +612,18 @@
     {
         return m_windowsBlockCompositing;
     }
+    int animationCurve() const {
+      return m_animationCurve;
+    }
+    int latencyControl() const {
+      return m_latencyControl;
+    }
+    int maxLatency() const {
+      return m_maxLatency;
+    }
+    int minLatency() const {
+      return m_minLatency;
+    }
 
     QStringList modifierOnlyDBusShortcut(Qt::KeyboardModifier mod) const;
 
@@ -664,6 +678,7 @@
     void setUseCompositing(bool useCompositing);
     void setCompositingInitialized(bool compositingInitialized);
     void setHiddenPreviews(int hiddenPreviews);
+    void setUnredirectFullscreen(bool unredirectFullscreen);
     void setGlSmoothScale(int glSmoothScale);
     void setXrenderSmoothScale(bool xrenderSmoothScale);
     void setMaxFpsInterval(qint64 maxFpsInterval);
@@ -675,6 +690,10 @@
     void setGlPreferBufferSwap(char glPreferBufferSwap);
     void setGlPlatformInterface(OpenGLPlatformInterface interface);
     void setWindowsBlockCompositing(bool set);
+    void setAnimationCurve(int curve);
+    void setLatencyControl(int index);
+    void setMaxLatency(int val);
+    void setMinLatency(int val);
 
     // default values
     static WindowOperation defaultOperationTitlebarDblClick() {
@@ -752,6 +771,9 @@
     static HiddenPreviews defaultHiddenPreviews() {
         return HiddenPreviewsShown;
     }
+    static bool defaultUnredirectFullscreen() {
+        return true;
+    }
     static int defaultGlSmoothScale() {
         return 2;
     }
@@ -788,6 +810,18 @@
     static int defaultAnimationSpeed() {
         return 3;
     }
+    static int defaultAnimationCurve() {
+      return 2;
+    }
+    static int defaultLatencyControl() {
+      return 1;
+    }
+    static int defaultMaxLatency() {
+      return 8;
+    }
+    static int defaultMinLatency() {
+      return 0;
+    }
 
     /**
      * Performs loading all settings except compositing related.
@@ -855,6 +889,7 @@
     void useCompositingChanged();
     void compositingInitializedChanged();
     void hiddenPreviewsChanged();
+    void unredirectFullscreenChanged();
     void glSmoothScaleChanged();
     void xrenderSmoothScaleChanged();
     void maxFpsIntervalChanged();
@@ -866,6 +901,10 @@
     void glPreferBufferSwapChanged();
     void glPlatformInterfaceChanged();
     void windowsBlockCompositingChanged();
+    void animationCurveChanged();
+    void latencyControlChanged();
+    void maxLatencyChanged();
+    void minLatencyChanged();
 
     void configChanged();
 
@@ -900,6 +939,7 @@
     bool m_useCompositing;
     bool m_compositingInitialized;
     HiddenPreviews m_hiddenPreviews;
+    bool m_unredirectFullscreen;
     int m_glSmoothScale;
     bool m_xrenderSmoothScale;
     qint64 m_maxFpsInterval;
@@ -912,6 +952,10 @@
     GlSwapStrategy m_glPreferBufferSwap;
     OpenGLPlatformInterface m_glPlatformInterface;
     bool m_windowsBlockCompositing;
+    int m_animationCurve;
+    int m_latencyControl;
+    int m_maxLatency;
+    int m_minLatency;
 
     WindowOperation OpTitlebarDblClick;
     WindowOperation opMaxButtonRightClick = defaultOperationMaxButtonRightClick();
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/patch.sh kwin-lowlatency/patch.sh
--- kwin-5.16.2/patch.sh	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/patch.sh	2019-06-25 23:16:16.693094220 +0300
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+klpath=${PWD##*/}
+minorVer=1
+version=$(sed -rn "s/^set\(PROJECT_VERSION \"([0-9.]+)\"\)$/\1/p" CMakeLists.txt)
+
+cd ..
+if [ ! -e kwin-$version.tar.xz ]
+  then wget https://download.kde.org/stable/plasma/$version/kwin-$version.tar.xz || exit 1
+fi
+
+tar -xf kwin-$version.tar.xz
+diff -ruNx .git -x build -x .kdev4 -x po kwin-$version $klpath > kwin-lowlatency-$version-$minorVer.patch
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/platformsupport/scenes/opengl/abstract_egl_backend.cpp kwin-lowlatency/platformsupport/scenes/opengl/abstract_egl_backend.cpp
--- kwin-5.16.2/platformsupport/scenes/opengl/abstract_egl_backend.cpp	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/platformsupport/scenes/opengl/abstract_egl_backend.cpp	2019-06-25 23:16:16.694094219 +0300
@@ -131,6 +131,8 @@
 {
     GLPlatform *glPlatform = GLPlatform::instance();
     glPlatform->detect(EglPlatformInterface);
+    //if (GLPlatform::instance()->driver() == Driver_Intel)
+        //options->setUnredirectFullscreen(false); // bug #252817 which I'm not fixing yet
     options->setGlPreferBufferSwap(options->glPreferBufferSwap()); // resolve autosetting
     if (options->glPreferBufferSwap() == Options::AutoSwapStrategy)
         options->setGlPreferBufferSwap('e'); // for unknown drivers - should not happen
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/plugins/platforms/drm/egl_gbm_backend.cpp kwin-lowlatency/plugins/platforms/drm/egl_gbm_backend.cpp
--- kwin-5.16.2/plugins/platforms/drm/egl_gbm_backend.cpp	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/plugins/platforms/drm/egl_gbm_backend.cpp	2019-06-25 23:16:16.698094212 +0300
@@ -313,6 +313,7 @@
         m_remoteaccessManager->passBuffer(o.output, o.buffer);
     }
     m_backend->present(o.buffer, o.output);
+    glFinish();
 
     if (supportsBufferAge()) {
         eglQuerySurface(eglDisplay(), o.eglSurface, EGL_BUFFER_AGE_EXT, &o.bufferAge);
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/plugins/platforms/x11/standalone/glxbackend.cpp kwin-lowlatency/plugins/platforms/x11/standalone/glxbackend.cpp
--- kwin-5.16.2/plugins/platforms/x11/standalone/glxbackend.cpp	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/plugins/platforms/x11/standalone/glxbackend.cpp	2019-06-25 23:16:16.706094199 +0300
@@ -206,6 +206,16 @@
     // Initialize OpenGL
     GLPlatform *glPlatform = GLPlatform::instance();
     glPlatform->detect(GlxPlatformInterface);
+    //if (GLPlatform::instance()->driver() == Driver_Intel)
+        //options->setUnredirectFullscreen(false); // bug #252817
+    // HACK! please replace with a better solution soon
+    if (GLPlatform::instance()->driver() == Driver_Intel) {
+      useHorribleHack=true; // issue #13
+    }
+    // NVIDIA doesn't freeze on that wait sync function
+    if (GLPlatform::instance()->driver() == Driver_NVidia) {
+      useWaitSync=true; // issue #17
+    }
     options->setGlPreferBufferSwap(options->glPreferBufferSwap()); // resolve autosetting
     if (options->glPreferBufferSwap() == Options::AutoSwapStrategy)
         options->setGlPreferBufferSwap('e'); // for unknown drivers - should not happen
@@ -245,24 +255,21 @@
     const bool wantSync = options->glPreferBufferSwap() != Options::NoSwapEncourage;
     if (wantSync && glXIsDirect(display(), ctx)) {
         if (haveSwapInterval) { // glXSwapInterval is preferred being more reliable
-            setSwapInterval(1);
-            setSyncsToVBlank(true);
-            const QByteArray tripleBuffer = qgetenv("KWIN_TRIPLE_BUFFER");
-            if (!tripleBuffer.isEmpty()) {
-                setBlocksForRetrace(qstrcmp(tripleBuffer, "0") == 0);
-                gs_tripleBufferUndetected = false;
-            }
-            gs_tripleBufferNeedsDetection = gs_tripleBufferUndetected;
-        } else if (hasExtension(QByteArrayLiteral("GLX_SGI_video_sync"))) {
+            setSwapInterval(1); // but adds latency. see below
+        } else {
+          qCWarning(KWIN_X11STANDALONE) << "TEARING ALERT! unable to set swap interval";
+        }
+        if (hasExtension(QByteArrayLiteral("GLX_SGI_video_sync"))) {
+            // we still need this extension for lowering latency.
             unsigned int sync;
             if (glXGetVideoSyncSGI(&sync) == 0 && glXWaitVideoSyncSGI(1, 0, &sync) == 0) {
                 setSyncsToVBlank(true);
                 setBlocksForRetrace(true);
                 haveWaitSync = true;
             } else
-                qCWarning(KWIN_X11STANDALONE) << "NO VSYNC! glXSwapInterval is not supported, glXWaitVideoSync is supported but broken";
+                qCWarning(KWIN_X11STANDALONE) << "HIGH LATENCY ALERT! glXWaitVideoSync is supported but broken";
         } else
-            qCWarning(KWIN_X11STANDALONE) << "NO VSYNC! neither glSwapInterval nor glXWaitVideoSync are supported";
+            qCWarning(KWIN_X11STANDALONE) << "HIGH LATENCY ALERT! glXWaitVideoSync is not supported";
     } else {
         // disable v-sync (if possible)
         setSwapInterval(0);
@@ -705,7 +712,7 @@
                 }
             }
         } else {
-            waitSync();
+            if (useWaitSync) waitSync();
             glXSwapBuffers(display(), glxWindow);
         }
         if (supportsBufferAge()) {
@@ -722,6 +729,23 @@
         copyPixels(lastDamage());
         glDrawBuffer(GL_BACK);
     }
+    if (useHorribleHack) {
+      // HACK HACK HACK! please replace with a better solution soon
+      unsigned int oldSync, sync;
+      glXGetVideoSyncSGI(&sync);
+      oldSync=sync;
+      while (1) {
+        glXGetVideoSyncSGI(&sync);
+        if (sync!=oldSync) break;
+        usleep(1000);
+      }
+    } else {
+      if (useWaitSync) {
+        waitSync();
+      } else {
+        glFinish();
+      }
+    }
 
     setLastDamage(QRegion());
     if (!supportsBufferAge()) {
@@ -795,15 +819,8 @@
 
     setLastDamage(renderedRegion);
 
-    if (!blocksForRetrace()) {
-        // This also sets lastDamage to empty which prevents the frame from
-        // being posted again when prepareRenderingFrame() is called.
-        present();
-    } else {
-        // Make sure that the GPU begins processing the command stream
-        // now and not the next time prepareRenderingFrame() is called.
-        glFlush();
-    }
+    // just present. this is the culprit.
+    present();
 
     if (overlayWindow()->window())  // show the window only after the first pass,
         overlayWindow()->show();   // since that pass may take long
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/plugins/platforms/x11/standalone/glxbackend.h kwin-lowlatency/plugins/platforms/x11/standalone/glxbackend.h
--- kwin-5.16.2/plugins/platforms/x11/standalone/glxbackend.h	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/plugins/platforms/x11/standalone/glxbackend.h	2019-06-25 23:16:16.706094199 +0300
@@ -118,6 +118,8 @@
     bool m_haveINTELSwapEvent = false;
     bool haveSwapInterval = false;
     bool haveWaitSync = false;
+    bool useHorribleHack = false;
+    bool useWaitSync = false;
     Display *m_x11Display;
     SwapProfiler m_swapProfiler;
     friend class GlxTexture;
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/README.md kwin-lowlatency/README.md
--- kwin-5.16.2/README.md	2019-06-25 14:43:42.000000000 +0300
+++ kwin-lowlatency/README.md	2019-06-25 23:16:16.630094325 +0300
@@ -1,48 +1,197 @@
-# KWin
+# KWin-lowlatency
 
-KWin is an easy to use, but flexible, composited Window Manager for Xorg windowing systems (Wayland, X11) on Linux. Its primary usage is in conjunction with a Desktop Shell (e.g. KDE Plasma Desktop). KWin is designed to go out of the way; users should not notice that they use a window manager at all. Nevertheless KWin provides a steep learning curve for advanced features, which are available, if they do not conflict with the primary mission. KWin does not have a dedicated targeted user group, but follows the targeted user group of the Desktop Shell using KWin as it's window manager.
+KWin-lowlatency is my attempt to reduce latency and stuttering in the popular KWin compositor used in KDE.
 
-## KWin is not...
+## background
 
- * a standalone window manager (c.f. openbox, i3) and does not provide any functionality belonging to a Desktop Shell.
- * a replacement for window managers designed for use with a specific Desktop Shell (e.g. GNOME Shell)
- * a minimalistic window manager
- * designed for use without compositing or for X11 network transparency, though both are possible.
+stock KWin has a major issue regarding stuttering. it stutters heavily, and if you don't want that, then you have the latency problem (of up to 50ms!).
 
-# Contacting KWin development team
+the rationale for such a problem is that KWin uses a weird method to paint the screen.
+instead of simply sync'ing to vblank, it uses a timer. yeah, a **timer** that is off-sync with the vblank interval.
+you can prove this by disabling VSync in the system settings. you'll see just 1 line of tearing in your screen, and well, that's the time it swaps due to the timer.
+
+in order to "fix" this under vanilla KWin, a typical solution is to insert this in kwinrc:
+
+```
+MaxFPS=200
+RefreshRate=200
+```
+
+effectively making the timer faster than the actual screen's rate, forcing VSync at some point.
+
+however, this introduces additional output lag, which varies depending on your driver, but usually it's 50ms (still too high).
+you can prove this by moving a window. you'll see the cursor being ahead of the title bar, or at least so under X.
+
+so, how to fix this? let's ditch the timer and let us access the VBlank interval directly.
+
+but how do we do that? by using glFinish.
+
+this is a much, **much** better solution over glXWaitVideoSyncSGI, as it achieves the same effect, doesn't have a chance of freezing under Mesa, and may work under EGL on X and Wayland.
+
+now, by doing this, we have a proper desktop without stuttering, but the lag persists...
+
+after digging deep into the code, i found this piece of code in particular, which is pretty much the culprit:
+
+```
+if (!blocksForRetrace()) {
+  // This also sets lastDamage to empty which prevents the frame from
+  // being posted again when prepareRenderingFrame() is called.
+  present();
+} else {
+  // Make sure that the GPU begins processing the command stream
+  // now and not the next time prepareRenderingFrame() is called.
+  glFlush();
+}
+```
+
+by removing this code and simply presenting as soon as possible (we're blocking for retrace anyway due to the glFinish thingy), we cut off 1 whole frame of lag!
+
+but hey, can we go further? yes, of course!
+
+now, by sleeping for a very few milliseconds (up to 8 in high-end systems) the compositor has more time for user input before rendering, which further reduces latency.
+
+the reason why only up to 8ms is because any further would leave little room for rendering, and that will actually produce more stuttering than fix it.
+
+## KWin-lowlatency is not...
+
+* perfect. it tries its best to deliver low-latency no-stutter video, but I can't promise this is always the case.
+  as an example, it will stutter if you select another window, or if you have too many windows open.
+* truly designed for low-end systems. if you use KWin-lowlatency in one of them, you may experience stuttering.
+
+# installation
+
+## Arch Linux
+
+[kwin-lowlatency is available in the AUR](https://aur.archlinux.org/packages/kwin-lowlatency).
+
+## Fedora
+
+ZaWertun provides pre-compiled packages [in the Copr](https://copr.fedorainfracloud.org/coprs/zawertun/kde/package/kwin-lowlatency/).
+
+## Gentoo
+
+[an overlay](https://github.com/agates/kwin-lowlatency-overlay) is available, courtesy of agates.
+
+## openSUSE Tumbleweed
+
+kwin-lowlatency can be found at [home:KAMiKAZOW:KDE](https://software.opensuse.org/download.html?project=home%3AKAMiKAZOW%3AKDE&package=kwin-lowlatency) (OBS).
+
+## other distributions/manual method
+
+you can compile/install this yourself if your distro isn't listed here (yes, I know Ubuntu is missing) or if you want to.
+
+### acquiring the source
+
+you can get the source code by using any of the following 2 methods:
+
+#### git repo clone
+
+```
+$ git clone https://github.com/tildearrow/kwin-lowlatency.git
+$ cd kwin-lowlatency
+```
+
+you may want to check the current stable version out:
+
+```
+$ git checkout v5.15.5
+```
+
+#### patch format
+
+download stock KWin source and patch file:
+
+```
+$ wget https://download.kde.org/stable/plasma/5.15.5/kwin-5.15.5.tar.xz
+$ wget http://tildearrow.zapto.org/storage/kwin-lowlatency/kwin-lowlatency-5.15.5.patch
+```
+
+extract:
+
+```
+$ tar -xvf kwin-5.15.5.tar.xz
+```
+
+patch:
+
+```
+$ cd kwin-5.15.5
+$ patch -p1 < ../kwin-lowlatency-5.15.5.patch
+```
+
+### building
+
+```
+$ mkdir build
+$ cd build
+$ cmake -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_INSTALL_LIBDIR=lib -DCMAKE_INSTALL_LIBEXECDIR=lib -DBUILD_TESTING=OFF
+$ make
+```
+
+### installing
+
+```
+$ sudo make install
+```
+
+# contacting original KWin development team
 
  * mailing list: [kwin@kde.org](https://mail.kde.org/mailman/listinfo/kwin)
  * IRC: #kwin on freenode
 
-# Support
-## Application Developer
-If you are an application developer having questions regarding windowing systems (either X11 or Wayland) please do not hesitate to contact us. Preferable through our mailing list. Ideally subscribe to the mailing list, so that your mail doesn't get stuck in the moderation queue.
+# additional options menu
 
-## End user
-Please contact the support channels of your Linux distribution for user support. The KWin development team does not provide end user support.
+KWin-lowlatency introduces few extra options in System Settings > Display and Monitor > Compositor. these are:
 
-# Reporting bugs
+- animation curve: allows you to make animations look smoother. I have a gripe with linear animations, hence this option. i'll post a video about this later.
+- latency/stutter control: use if you have a high-end system and want lower latency, or if you're having stuttering and want to reduce it.
+- maximum/minimum latency reduction: allows you to configure the latency reduction window. examples (min/max): 8/0 default, 0/0 disable latency reduction, and 8/8 lowest latency possible. this is limited to 8ms, since any further would cause major stuttering and slowdowns.
 
-Please use [KDE's bugtracker](https://bugs.kde.org) and report for [product KWin](https://bugs.kde.org/enter_bug.cgi?product=kwin).
+# misc/FAQ
 
-# Developing on KWin
-Please refer to [hacking documentation](HACKING.md) for how to build and start KWin. Further information about KWin's test suite can be found in [TESTING.md](TESTING.md).
+> Ubuntu Ubuntu Ubuntu
+
+i'm working on it...
 
-## Guidelines for new features
+> what's this "Paint cursor" effect in Desktop Effects?
 
-A new Feature can only be added to KWin if:
+it's an effect I wrote back in 2018 when experimenting with kmsgrab for some private recordings.
+it basically redraws the cursor. this may seem redundant, but actually is helpful for recording with kmsgrab (since it doesn't draw the hardware sprite).
 
- * it does not violate the primary missions as stated at the start of this document
- * it does not introduce instabilities
- * it is maintained, that is bugs are fixed in a timely manner (second next minor release) if it is not a corner case.
- * it works together with all existing features
- * it supports both single and multi screen (xrandr)
- * it adds a significant advantage
- * it is feature complete, that is supports at least all useful features from competitive implementations
- * it is not a special case for a small user group
- * it does not increase code complexity significantly
- * it does not affect KWin's license (GPLv2+)
+> will this work under Wayland?
 
-All new added features are under probation, that is if any of the non-functional requirements as listed above do not hold true in the next two feature releases, the added feature will be removed again.
+no, it won't, but I am working on it. so far using DRM VBlank only showed negative results, with applications running at half speed. now i'm trying again with glFinish and friends...
+
+> i'm using the `modesetting` driver (instead of the `amdgpu` DDX driver) under an AMD card, and can see some latency. how do I fix this?
+
+an option will come soon.
+
+> do you have any plans to upstream this?
+
+at this moment, not really:
+
+- i still can't ensure this will work everywhere (but it should).
+- this patchset brings full-screen unredirection back, which is a feature the KDE devs definitely [don't want to see in upstream](https://blog.martin-graesslin.com/blog/2016/08/opengl-changes-in-kwin-compositing/) since they have another "approach" (allow apps to block compositing).
+  - the problem with their approach is that it means every app must support it in order to work, which is something not every app does. on the other hand, unredirection works for most apps, and doesn't require developers to change their code for it to work.
+  - another problem is that instead of suspending compositing, it **disables** compositing. this means you get to see a few frames of an ugly desktop when the app quits. this doesn't happen with unredirection.
+- furthermore, this also brings back "close" option in Present Windows, which once again the KDE devs despise.
+
+> unredirection is not working.
+
+please see [unredirect.md](https://github.com/tildearrow/kwin-lowlatency/blob/Plasma/5.15/unredirect.md) for known issues. you may file a bug report as well.
+
+# support
+
+use the issues section at the top.
+
+# bugs?
+
+use the issues section at the top. **but wait!** before reporting an issue, first test it again on [the official KWin](https://cgit.kde.org/kwin.git/) to determine whether this is really a KWin-lowlatency-only bug.
+
+if the bug also reproduces in official KWin, please file a bug on [their bug tracker](https://bugs.kde.org/enter_bug.cgi?product=kwin) instead.
+
+# Developing on KWin
+
+Please refer to [hacking documentation](HACKING.md) for how to build and start KWin. Further information about KWin's test suite can be found in [TESTING.md](TESTING.md).
 
-The same non functional requirements hold true for any kind of plugins (effects, scripts, etc.). It is suggested to use scripted plugins and distribute them separately.
+no, sorry, there are no tests for the low-latency features yet.
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/scene.cpp kwin-lowlatency/scene.cpp
--- kwin-5.16.2/scene.cpp	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/scene.cpp	2019-06-25 23:16:16.819094011 +0300
@@ -233,6 +233,9 @@
             continue;
         }
         phase2.append({w, infiniteRegion(), data.clip, data.mask, data.quads});
+        // transformations require window pixmap
+        w->suspendUnredirect(data.mask
+                             & (PAINT_WINDOW_TRANSLUCENT | PAINT_SCREEN_TRANSFORMED | PAINT_WINDOW_TRANSFORMED));
     }
 
     foreach (const Phase2Data & d, phase2) {
@@ -306,11 +309,14 @@
         }
 #endif
         if (!w->isPaintingEnabled()) {
+            w->suspendUnredirect(true);
             continue;
         }
         dirtyArea |= data.paint;
         // Schedule the window for painting
         phase2data.append({w, data.paint, data.clip, data.mask, data.quads});
+        // no transformations, but translucency requires window pixmap
+        w->suspendUnredirect(data.mask & PAINT_WINDOW_TRANSLUCENT);
     }
 
     // Save the part of the repaint region that's exclusively rendered to
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/scene.h kwin-lowlatency/scene.h
--- kwin-5.16.2/scene.h	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/scene.h	2019-06-25 23:16:16.819094011 +0300
@@ -337,6 +337,7 @@
     void updateToplevel(Toplevel* c);
     // creates initial quad list for the window
     virtual WindowQuadList buildQuads(bool force = false) const;
+    void suspendUnredirect(bool suspend);
     void updateShadow(Shadow* shadow);
     const Shadow* shadow() const;
     Shadow* shadow();
@@ -597,6 +598,12 @@
 }
 
 inline
+void Scene::Window::suspendUnredirect(bool suspend)
+{
+    toplevel->suspendUnredirect(suspend);
+}
+
+inline
 const Shadow* Scene::Window::shadow() const
 {
     return m_shadow;
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/scripting/scriptedeffect.cpp kwin-lowlatency/scripting/scriptedeffect.cpp
--- kwin-5.16.2/scripting/scriptedeffect.cpp	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/scripting/scriptedeffect.cpp	2019-06-25 23:16:16.820094010 +0300
@@ -153,7 +153,21 @@
         settings.curve = static_cast<QEasingCurve::Type>(curve.toInt32());
         settings.set |= AnimationSettings::Curve;
     } else {
-        settings.curve = QEasingCurve::Linear;
+#ifndef KWINLL_NO_OPTIONS
+      switch (options->animationCurve()) {
+        case 1:
+          settings.curve = QEasingCurve::InOutQuad;
+          break;
+        case 2:
+          settings.curve = QEasingCurve::InOutSine;
+          break;
+        default:
+          settings.curve = QEasingCurve::Linear;
+          break;
+      }
+#else
+      settings.curve = QEasingCurve::InOutSine;
+#endif
     }
 
     QScriptValue type = object.property(QStringLiteral("type"));
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/shell_client.cpp kwin-lowlatency/shell_client.cpp
--- kwin-5.16.2/shell_client.cpp	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/shell_client.cpp	2019-06-25 23:16:16.823094005 +0300
@@ -483,6 +483,12 @@
     return AbstractClient::layerForDock();
 }
 
+bool ShellClient::shouldUnredirect() const
+{
+    // TODO: unredirect for fullscreen
+    return false;
+}
+
 QRect ShellClient::transparentRect() const
 {
     // TODO: implement
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/shell_client.h kwin-lowlatency/shell_client.h
--- kwin-5.16.2/shell_client.h	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/shell_client.h	2019-06-25 23:16:16.823094005 +0300
@@ -61,6 +61,7 @@
     QPoint clientContentPos() const override;
     QSize clientSize() const override;
     QRect transparentRect() const override;
+    bool shouldUnredirect() const override;
     NET::WindowType windowType(bool direct = false, int supported_types = 0) const override;
     void debug(QDebug &stream) const override;
     double opacity() const override;
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/toplevel.cpp kwin-lowlatency/toplevel.cpp
--- kwin-5.16.2/toplevel.cpp	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/toplevel.cpp	2019-06-25 23:16:16.825094001 +0300
@@ -51,6 +51,8 @@
     , effect_window(NULL)
     , m_clientMachine(new ClientMachine(this))
     , wmClientLeaderWin(0)
+    , unredirect(false)
+    , unredirectSuspend(false)
     , m_damageReplyPending(false)
     , m_screen(0)
     , m_skipCloseAnimation(false)
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/toplevel.h kwin-lowlatency/toplevel.h
--- kwin-5.16.2/toplevel.h	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/toplevel.h	2019-06-25 23:16:16.825094001 +0300
@@ -335,6 +335,9 @@
     bool hasAlpha() const;
     virtual bool setupCompositing();
     virtual void finishCompositing(ReleaseReason releaseReason = ReleaseReason::Release);
+    bool updateUnredirectedState();
+    bool unredirected() const;
+    void suspendUnredirect(bool suspend);
     Q_INVOKABLE void addRepaint(const QRect& r);
     Q_INVOKABLE void addRepaint(const QRegion& r);
     Q_INVOKABLE void addRepaint(int x, int y, int w, int h);
@@ -592,6 +595,7 @@
     void disownDataPassedToDeleted();
     friend QDebug& operator<<(QDebug& stream, const Toplevel*);
     void deleteEffectWindow();
+    virtual bool shouldUnredirect() const = 0;
     void setDepth(int depth);
     QRect geom;
     xcb_visualid_t m_visual;
@@ -616,6 +620,8 @@
     QByteArray resource_class;
     ClientMachine *m_clientMachine;
     WId wmClientLeaderWin;
+    bool unredirect;
+    bool unredirectSuspend; // when unredirected, but pixmap is needed temporarily
     bool m_damageReplyPending;
     QRegion opaque_region;
     xcb_xfixes_fetch_region_cookie_t m_regionCookie;
@@ -873,6 +879,11 @@
     return resource_class; // it is always lowercase
 }
 
+inline bool Toplevel::unredirected() const
+{
+    return unredirect;
+}
+
 inline const ClientMachine *Toplevel::clientMachine() const
 {
     return m_clientMachine;
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/unmanaged.h kwin-lowlatency/unmanaged.h
--- kwin-5.16.2/unmanaged.h	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/unmanaged.h	2019-06-25 23:16:16.825094001 +0300
@@ -55,6 +55,7 @@
     void release(ReleaseReason releaseReason = ReleaseReason::Release);
 protected:
     virtual void debug(QDebug& stream) const;
+    virtual bool shouldUnredirect() const;
     void addDamage(const QRegion &damage) override;
 private:
     virtual ~Unmanaged(); // use release()
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/unredirect.md kwin-lowlatency/unredirect.md
--- kwin-5.16.2/unredirect.md	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/unredirect.md	2019-06-25 23:16:16.826094000 +0300
@@ -0,0 +1,30 @@
+# fullscreen unredirection
+
+this version of the compositor brings back the ability to unredirect fullscreen windows, which has been originally removed by the KDE developers because they thought their "block compositing" approach would be the future.
+
+their "block compositing" approach has 3 flaws:
+
+- it actually fully disables the compositor (which means it will take a while for it to re-enable)
+- it can get annoying (especially with SDL apps. SDL requests KWin to disable compositing, even if not in fullscreen!)
+- every application must be coded to support it. with unredirection it works on most apps without giving the developers extra burden.
+
+however, fullscreen unredirection also has its flaws:
+
+- in some setups it may crash, according to KDE developers
+- some applications may interfere and prevent it from working
+
+# non-working/crashing setups
+
+none so far. please contact me if your setup causes KWin to crash with unredirection.
+
+# known issues
+
+the following applications prevent unredirection from working:
+
+- calfjackhost
+- [latte-dock](https://github.com/tildearrow/kwin-lowlatency/issues/1#issuecomment-483403493) (sometimes)
+- [some Wine applications](https://github.com/tildearrow/kwin-lowlatency/issues/1#issuecomment-491345833). so far reproduces with Battle.net and taskmgr.
+
+the following applications may misbehave when unredirection is enabled:
+
+- some Wine applications. after switching windows they may turn black.
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/wayStart kwin-lowlatency/wayStart
--- kwin-5.16.2/wayStart	1970-01-01 03:00:00.000000000 +0300
+++ kwin-lowlatency/wayStart	2019-06-25 23:16:16.827093998 +0300
@@ -0,0 +1,248 @@
+#!/bin/sh
+# quick-start a Plasma Wayland session with kwin-lowlatency
+
+if [ ! -e build/bin/kwin_wayland ]
+  then echo "please build KWin first."
+       exit 1
+fi
+
+# We need to create config folder so we can write startupconfigkeys
+if [  ${XDG_CONFIG_HOME} ]; then
+  configDir=$XDG_CONFIG_HOME;
+else
+  configDir=${HOME}/.config; #this is the default, http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
+fi
+sysConfigDirs=${XDG_CONFIG_DIRS:-/etc/xdg}
+
+# We need to create config folder so we can write startupconfigkeys
+mkdir -p $configDir
+
+#This is basically setting defaults so we can use them with kstartupconfig5
+cat >$configDir/startupconfigkeys <<EOF
+kcminputrc Mouse cursorTheme 'breeze_cursors'
+kcminputrc Mouse cursorSize ''
+ksplashrc KSplash Theme Breeze
+ksplashrc KSplash Engine KSplashQML
+kcmfonts General forceFontDPIWayland 0
+EOF
+
+# preload the user's locale on first start
+plasmalocalerc=$configDir/plasma-localerc
+test -f $plasmalocalerc || {
+cat >$plasmalocalerc <<EOF
+[Formats]
+LANG=$LANG
+EOF
+}
+
+# export LC_* variables set by kcmshell5 formats into environment
+# so it can be picked up by QLocale and friends.
+exportformatssettings=$configDir/plasma-locale-settings.sh
+test -f $exportformatssettings && {
+    . $exportformatssettings
+}
+
+# Write a default kdeglobals file to set up the font
+kdeglobalsfile=$configDir/kdeglobals
+test -f $kdeglobalsfile || {
+cat >$kdeglobalsfile <<EOF
+[General]
+XftAntialias=true
+XftHintStyle=hintmedium
+XftSubPixel=none
+EOF
+}
+
+# Make sure the Oxygen font is installed
+# This is necessary for setups where CMAKE_INSTALL_PREFIX
+# is not in /usr. fontconfig looks in /usr, ~/.fonts and
+# $XDG_DATA_HOME for fonts. In this case, we symlink the
+# Oxygen font under ${XDG_DATA_HOME} and make it known to
+# fontconfig
+
+usr_share="/usr/share"
+install_share="/usr/share"
+
+if [ ! $install_share = $usr_share ]; then
+
+    if [ ${XDG_DATA_HOME} ]; then
+        fontsDir="${XDG_DATA_HOME}/fonts"
+    else
+        fontsDir="${HOME}/.fonts"
+    fi
+
+    test -d $fontsDir || {
+        mkdir -p $fontsDir
+    }
+
+    oxygenDir=$fontsDir/truetype/oxygen
+    prefixDir="/usr/share/fonts/truetype/oxygen"
+
+    # if the oxygen dir doesn't exist, create a symlink to be sure that the
+    # Oxygen font is available to the user
+    test -d $oxygenDir || test -d $prefixDir && {
+        test -h $oxygenDir || ln -s $prefixDir $oxygenDir && fc-cache $oxygenDir
+    }
+fi
+
+kstartupconfig5
+returncode=$?
+if test $returncode -ne 0; then
+    exit 1
+fi
+[ -r $configDir/startupconfig ] && . $configDir/startupconfig
+
+#Manually disable auto scaling because we are scaling above
+#otherwise apps that manually opt in for high DPI get auto scaled by the developer AND scaled by the wl_output
+export QT_AUTO_SCREEN_SCALE_FACTOR=0
+
+# XCursor mouse theme needs to be applied here to work even for kded or ksmserver
+if test -n "$kcminputrc_mouse_cursortheme" -o -n "$kcminputrc_mouse_cursorsize" ; then
+    
+
+    # TODO: is kapplymousetheme a core app?
+    #kapplymousetheme "$kcminputrc_mouse_cursortheme" "$kcminputrc_mouse_cursorsize"
+    if test $? -eq 10; then
+        XCURSOR_THEME=breeze_cursors
+        export XCURSOR_THEME
+    elif test -n "$kcminputrc_mouse_cursortheme"; then
+        XCURSOR_THEME="$kcminputrc_mouse_cursortheme"
+        export XCURSOR_THEME
+    fi
+    if test -n "$kcminputrc_mouse_cursorsize"; then
+        XCURSOR_SIZE="$kcminputrc_mouse_cursorsize"
+        export XCURSOR_SIZE
+    fi
+fi
+
+if test "$kcmfonts_general_forcefontdpiwayland" -ne 0; then
+    export QT_WAYLAND_FORCE_DPI=$kcmfonts_general_forcefontdpiwayland
+else
+    export QT_WAYLAND_FORCE_DPI=96
+fi
+
+# Get a property value from org.freedesktop.locale1
+queryLocale1() {
+    qdbus --system org.freedesktop.locale1 /org/freedesktop/locale1 "$1"
+}
+
+# Query whether org.freedesktop.locale1 is available. If it is, try to
+# set XKB_DEFAULT_{MODEL,LAYOUT,VARIANT,OPTIONS} accordingly.
+if qdbus --system org.freedesktop.locale1 >/dev/null 2>/dev/null; then
+    # Do not overwrite existing values. There is no point in setting only some
+    # of them as then they would not match anymore.
+    if [ -z "${XKB_DEFAULT_MODEL}" -a -z "${XKB_DEFAULT_LAYOUT}" -a \
+         -z "${XKB_DEFAULT_VARIANT}" -a -z "${XKB_DEFAULT_OPTIONS}" ]; then
+        X11MODEL="$(queryLocale1 org.freedesktop.locale1.X11Model)"
+        X11LAYOUT="$(queryLocale1 org.freedesktop.locale1.X11Layout)"
+        X11VARIANT="$(queryLocale1 org.freedesktop.locale1.X11Variant)"
+        X11OPTIONS="$(queryLocale1 org.freedesktop.locale1.X11Options)"
+        [ -n "${X11MODEL}" ] && export XKB_DEFAULT_MODEL="${X11MODEL}"
+        [ -n "${X11LAYOUT}" ] && export XKB_DEFAULT_LAYOUT="${X11LAYOUT}"
+        [ -n "${X11VARIANT}" ] && export XKB_DEFAULT_VARIANT="${X11VARIANT}"
+        [ -n "${X11OPTIONS}" ] && export XKB_DEFAULT_OPTIONS="${X11OPTIONS}"
+    fi
+fi
+
+# Source scripts found in <config locations>/plasma-workspace/env/*.sh
+# (where <config locations> correspond to the system and user's configuration
+# directories, as identified by Qt's qtpaths,  e.g.  $HOME/.config
+# and /etc/xdg/ on Linux)
+#
+# This is where you can define environment variables that will be available to
+# all KDE programs, so this is where you can run agents using e.g. eval `ssh-agent`
+# or eval `gpg-agent --daemon`.
+# Note: if you do that, you should also put "ssh-agent -k" as a shutdown script
+#
+# (see end of this file).
+# For anything else (that doesn't set env vars, or that needs a window manager),
+# better use the Autostart folder.
+
+scriptpath=`echo "$configDir:$sysConfigDirs" | tr ':' '\n'`
+
+for prefix in `echo $scriptpath`; do
+  for file in "$prefix"/plasma-workspace/env/*.sh; do
+    test -r "$file" && . "$file" || true
+  done
+done
+
+echo 'startplasmacompositor: Starting up...'  1>&2
+
+# Make sure that the KDE prefix is first in XDG_DATA_DIRS and that it's set at all.
+# The spec allows XDG_DATA_DIRS to be not set, but X session startup scripts tend
+# to set it to a list of paths *not* including the KDE prefix if it's not /usr or
+# /usr/local.
+if test -z "$XDG_DATA_DIRS"; then
+XDG_DATA_DIRS="/usr/share:/usr/share:/usr/local/share"
+fi
+export XDG_DATA_DIRS
+
+# Make sure that D-Bus is running
+if qdbus >/dev/null 2>/dev/null; then
+    : # ok
+else
+    echo 'startplasmacompositor: Could not start D-Bus. Can you call qdbus?'  1>&2
+    test -n "$ksplash_pid" && kill "$ksplash_pid" 2>/dev/null
+    exit 1
+fi
+
+
+# Mark that full KDE session is running (e.g. Konqueror preloading works only
+# with full KDE running). The KDE_FULL_SESSION property can be detected by
+# any X client connected to the same X session, even if not launched
+# directly from the KDE session but e.g. using "ssh -X", kdesu. $KDE_FULL_SESSION
+# however guarantees that the application is launched in the same environment
+# like the KDE session and that e.g. KDE utilities/libraries are available.
+# KDE_FULL_SESSION property is also only available since KDE 3.5.5.
+# The matching tests are:
+#   For $KDE_FULL_SESSION:
+#     if test -n "$KDE_FULL_SESSION"; then ... whatever
+#   For KDE_FULL_SESSION property:
+#     xprop -root | grep "^KDE_FULL_SESSION" >/dev/null 2>/dev/null
+#     if test $? -eq 0; then ... whatever
+#
+# Additionally there is (since KDE 3.5.7) $KDE_SESSION_UID with the uid
+# of the user running the KDE session. It should be rarely needed (e.g.
+# after sudo to prevent desktop-wide functionality in the new user's kded).
+#
+# Since KDE4 there is also KDE_SESSION_VERSION, containing the major version number.
+# Note that this didn't exist in KDE3, which can be detected by its absense and
+# the presence of KDE_FULL_SESSION.
+#
+KDE_FULL_SESSION=true
+export KDE_FULL_SESSION
+
+KDE_SESSION_VERSION=5
+export KDE_SESSION_VERSION
+
+KDE_SESSION_UID=`id -ru`
+export KDE_SESSION_UID
+
+XDG_CURRENT_DESKTOP=KDE
+export XDG_CURRENT_DESKTOP
+
+XDG_SESSION_TYPE=wayland
+export XDG_SESSION_TYPE
+
+# kwin_wayland can possibly also start dbus-activated services which need env variables.
+# In that case, the update in startplasma might be too late.
+if which dbus-update-activation-environment >/dev/null 2>/dev/null ; then
+    dbus-update-activation-environment --systemd --all
+else
+    /usr/lib/ksyncdbusenv
+fi
+if test $? -ne 0; then
+  # Startup error
+  echo 'startplasmacompositor: Could not sync environment to dbus.'  1>&2
+  exit 1
+fi
+
+QT_PLUGIN_PATH="$PWD/build/bin" ./build/bin/kwin_wayland --xwayland --libinput --exit-with-session=/usr/lib/startplasma
+
+echo 'startplasmacompositor: Shutting down...'  1>&2
+
+unset KDE_FULL_SESSION
+unset KDE_SESSION_VERSION
+unset KDE_SESSION_UID
+
+echo 'startplasmacompositor: Done.'  1>&2
diff -ruNx .git -x build -x .kdev4 -x po kwin-5.16.2/workspace.cpp kwin-lowlatency/workspace.cpp
--- kwin-5.16.2/workspace.cpp	2019-06-25 14:43:43.000000000 +0300
+++ kwin-lowlatency/workspace.cpp	2019-06-25 23:16:16.827093998 +0300
@@ -586,6 +586,10 @@
     StackingUpdatesBlocker blocker(this);
     Client* c = new Client();
     setupClientConnections(c);
+    connect(c, &Client::activeChanged, m_compositor, static_cast<void (Compositor::*)()>(&Compositor::checkUnredirect));
+    connect(c, SIGNAL(fullScreenChanged()), m_compositor, SLOT(checkUnredirect()));
+    connect(c, SIGNAL(geometryChanged()), m_compositor, SLOT(checkUnredirect()));
+    connect(c, SIGNAL(geometryShapeChanged(KWin::Toplevel*,QRect)), m_compositor, SLOT(checkUnredirect()));
     connect(c, SIGNAL(blockingCompositingChanged(KWin::Client*)), m_compositor, SLOT(updateCompositeBlocking(KWin::Client*)));
     connect(c, SIGNAL(clientFullScreenSet(KWin::Client*,bool,bool)), ScreenEdges::self(), SIGNAL(checkBlocking()));
     if (!c->manage(w, is_mapped)) {
