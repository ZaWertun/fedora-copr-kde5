diff '--color=auto' -r -U3 kwin-5.27.3.orig/src/plugins/screencast/screencaststream.cpp kwin-5.27.3/src/plugins/screencast/screencaststream.cpp
--- kwin-5.27.3.orig/src/plugins/screencast/screencaststream.cpp	2023-03-14 15:25:28.000000000 +0300
+++ kwin-5.27.3/src/plugins/screencast/screencaststream.cpp	2023-03-16 20:37:07.231698897 +0300
@@ -175,14 +175,34 @@
         uint32_t modifiersCount = SPA_POD_CHOICE_N_VALUES(modifierPod);
         uint64_t *modifiers = (uint64_t *)SPA_POD_CHOICE_VALUES(modifierPod);
         receivedModifiers = QVector<uint64_t>(modifiers, modifiers + modifiersCount);
+        // Remove duplicates
+        std::sort(receivedModifiers.begin(), receivedModifiers.end());
+        receivedModifiers.erase(std::unique(receivedModifiers.begin(), receivedModifiers.end()), receivedModifiers.end());
     }
     if (modifierProperty && (!pw->m_dmabufParams || !receivedModifiers.contains(pw->m_dmabufParams->modifier))) {
         if (modifierProperty->flags & SPA_POD_PROP_FLAG_DONT_FIXATE) {
+            // DRM_MOD_INVALID should be used as a last option. Do not just remove it it's the only
+            // item on the list
+            if (receivedModifiers.count() > 1)
+                receivedModifiers.removeAll(DRM_FORMAT_MOD_INVALID);
             pw->m_dmabufParams = kwinApp()->outputBackend()->testCreateDmaBuf(pw->m_resolution, spaVideoFormatToDrmFormat(pw->videoFormat.format), receivedModifiers);
         } else {
             pw->m_dmabufParams = kwinApp()->outputBackend()->testCreateDmaBuf(pw->m_resolution, spaVideoFormatToDrmFormat(pw->videoFormat.format), {DRM_FORMAT_MOD_INVALID});
         }
 
+        // In case we fail to use any modifier from the list of offered ones, remove these
+        // from our all future offerings, otherwise there will be no indication that it cannot
+        // be used and clients can go for it over and over
+        if (!pw->m_dmabufParams.has_value()) {
+            for (uint64_t modifier : receivedModifiers)
+                pw->m_modifiers.removeAll(modifier);
+        // Also in case DRM_FORMAT_MOD_INVALID was used and didn't fail, we still need to
+        // set it as our modifier, otherwise it would be set to default value (0) which is
+        // also a valid modifier, but not the one we want to actually use
+        } else if (receivedModifiers.count() == 1 && receivedModifiers.first() == DRM_FORMAT_MOD_INVALID) {
+            pw->m_dmabufParams->modifier = DRM_FORMAT_MOD_INVALID;
+        }
+
         qCDebug(KWIN_SCREENCAST) << "Stream dmabuf modifiers received, offering our best suited modifier" << pw->m_dmabufParams.has_value();
         char buffer[2048];
         auto params = pw->buildFormats(pw->m_dmabufParams.has_value(), buffer);
@@ -356,6 +376,8 @@
     // it could make sense to offer the same format as the source
     const auto format = m_source->hasAlphaChannel() ? SPA_VIDEO_FORMAT_BGRA : SPA_VIDEO_FORMAT_BGR;
     const int drmFormat = spaVideoFormatToDrmFormat(format);
+    // + support modifier-less DmaBufs
+    m_modifiers += DRM_FORMAT_MOD_INVALID;
     m_hasDmaBuf = kwinApp()->outputBackend()->testCreateDmaBuf(m_resolution, drmFormat, {DRM_FORMAT_MOD_INVALID}).has_value();
     m_modifiers = Compositor::self()->backend()->supportedFormats().value(drmFormat);
 
