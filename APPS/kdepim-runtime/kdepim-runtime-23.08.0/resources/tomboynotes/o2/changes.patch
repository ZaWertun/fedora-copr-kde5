diff --git a/src/o0abstractstore.h b/src/o0abstractstore.h
index 1397361..0464325 100644
--- a/src/o0abstractstore.h
+++ b/src/o0abstractstore.h
@@ -5,11 +5,13 @@
 #include <QString>
 
 /// Storage for strings.
-class O0AbstractStore: public QObject {
+class O0AbstractStore: public QObject
+{
     Q_OBJECT
 
 public:
-    explicit O0AbstractStore(QObject *parent = 0): QObject(parent) {
+    explicit O0AbstractStore(QObject *parent = 0): QObject(parent)
+    {
     }
 
     /// Retrieve a string value by key.
diff --git a/src/o0baseauth.cpp b/src/o0baseauth.cpp
index d4f052d..c021776 100644
--- a/src/o0baseauth.cpp
+++ b/src/o0baseauth.cpp
@@ -1,18 +1,20 @@
 #include <QDataStream>
 #include <QDebug>
 
-#include "o0baseauth.h"
-#include "o0globals.h"
-#include "o0settingsstore.h"
+#include "o2/o0baseauth.h"
+#include "o2/o0globals.h"
+#include "o2/o0settingsstore.h"
 
 static const quint16 DefaultLocalPort = 1965;
 
-O0BaseAuth::O0BaseAuth(QObject *parent): QObject(parent) {
+O0BaseAuth::O0BaseAuth(QObject *parent): QObject(parent)
+{
     localPort_ = DefaultLocalPort;
     store_ = new O0SettingsStore(O2_ENCRYPTION_KEY, this);
 }
 
-void O0BaseAuth::setStore(O0AbstractStore *store) {
+void O0BaseAuth::setStore(O0AbstractStore *store)
+{
     if (store_) {
         store_->deleteLater();
     }
@@ -25,74 +27,87 @@ void O0BaseAuth::setStore(O0AbstractStore *store) {
     }
 }
 
-bool O0BaseAuth::linked() {
+bool O0BaseAuth::linked()
+{
     QString key = QString(O2_KEY_LINKED).arg(clientId_);
     bool result = !store_->value(key).isEmpty();
-    qDebug() << "O0BaseAuth::linked:" << (result? "Yes": "No");
+    qDebug() << "O0BaseAuth::linked:" << (result ? "Yes" : "No");
     return result;
 }
 
-void O0BaseAuth::setLinked(bool v) {
-    qDebug() << "O0BaseAuth::setLinked:" << (v? "true": "false");
+void O0BaseAuth::setLinked(bool v)
+{
+    qDebug() << "O0BaseAuth::setLinked:" << (v ? "true" : "false");
     bool oldValue = linked();
     QString key = QString(O2_KEY_LINKED).arg(clientId_);
-    store_->setValue(key, v? "1": "");
+    store_->setValue(key, v ? "1" : "");
     if (oldValue != v) {
         Q_EMIT linkedChanged();
     }
 }
 
-QString O0BaseAuth::tokenSecret() {
+QString O0BaseAuth::tokenSecret()
+{
     QString key = QString(O2_KEY_TOKEN_SECRET).arg(clientId_);
     return store_->value(key);
 }
 
-void O0BaseAuth::setTokenSecret(const QString &v) {
+void O0BaseAuth::setTokenSecret(const QString &v)
+{
     QString key = QString(O2_KEY_TOKEN_SECRET).arg(clientId_);
     store_->setValue(key, v);
     Q_EMIT tokenSecretChanged();
 }
 
-QString O0BaseAuth::token() {
+QString O0BaseAuth::token()
+{
     QString key = QString(O2_KEY_TOKEN).arg(clientId_);
     return store_->value(key);
 }
 
-void O0BaseAuth::setToken(const QString &v) {
+void O0BaseAuth::setToken(const QString &v)
+{
     QString key = QString(O2_KEY_TOKEN).arg(clientId_);
     store_->setValue(key, v);
     Q_EMIT tokenChanged();
 }
 
-QString O0BaseAuth::clientId() {
+QString O0BaseAuth::clientId()
+{
     return clientId_;
 }
 
-void O0BaseAuth::setClientId(const QString &value) {
+void O0BaseAuth::setClientId(const QString &value)
+{
     clientId_ = value;
     Q_EMIT clientIdChanged();
 }
 
-QString O0BaseAuth::clientSecret() {
+QString O0BaseAuth::clientSecret()
+{
     return clientSecret_;
 }
 
-void O0BaseAuth::setClientSecret(const QString &value) {
+void O0BaseAuth::setClientSecret(const QString &value)
+{
     clientSecret_ = value;
     Q_EMIT clientSecretChanged();
 }
 
-int O0BaseAuth::localPort() {
+int O0BaseAuth::localPort()
+{
     return localPort_;
 }
 
-void O0BaseAuth::setLocalPort(int value) {
+void O0BaseAuth::setLocalPort(int value)
+{
     qDebug() << "O0BaseAuth::setLocalPort:" << value;
     localPort_ = value;
     Q_EMIT localPortChanged();
 }
 
-QVariantMap O0BaseAuth::extraTokens() {
+QVariantMap O0BaseAuth::extraTokens()
+{
     QString key = QString(O2_KEY_EXTRA_TOKENS).arg(clientId_);
     QString value = store_->value(key);
     QByteArray bytes = QByteArray::fromBase64(value.toLatin1());
@@ -101,7 +116,8 @@ QVariantMap O0BaseAuth::extraTokens() {
     return extraTokens_;
 }
 
-void O0BaseAuth::setExtraTokens(QVariantMap extraTokens) {
+void O0BaseAuth::setExtraTokens(QVariantMap extraTokens)
+{
     extraTokens_ = extraTokens;
     QByteArray bytes;
     QDataStream stream(&bytes, QIODevice::WriteOnly);
@@ -111,7 +127,8 @@ void O0BaseAuth::setExtraTokens(QVariantMap extraTokens) {
     Q_EMIT extraTokensChanged();
 }
 
-QByteArray O0BaseAuth::createQueryParameters(const QList<O0RequestParameter> &parameters) {
+QByteArray O0BaseAuth::createQueryParameters(const QList<O0RequestParameter> &parameters)
+{
     QByteArray ret;
     bool first = true;
     foreach (O0RequestParameter h, parameters) {
diff --git a/src/o0baseauth.h b/src/o0baseauth.h
index d8a68a2..c906edf 100644
--- a/src/o0baseauth.h
+++ b/src/o0baseauth.h
@@ -8,11 +8,12 @@
 #include <QUrl>
 #include <QVariantMap>
 
-#include "o0abstractstore.h"
-#include "o0requestparameter.h"
+#include "o2/o0abstractstore.h"
+#include "o2/o0requestparameter.h"
 
 /// Base class of OAuth authenticators
-class O0BaseAuth : public QObject {
+class O0BaseAuth : public QObject
+{
     Q_OBJECT
 
 public:
diff --git a/src/o0requestparameter.h b/src/o0requestparameter.h
index c793aad..c966987 100644
--- a/src/o0requestparameter.h
+++ b/src/o0requestparameter.h
@@ -4,8 +4,9 @@
 /// Request parameter (name-value pair) participating in authentication.
 struct O0RequestParameter {
     O0RequestParameter(const QByteArray &n, const QByteArray &v): name(n), value(v) {}
-    bool operator <(const O0RequestParameter &other) const {
-        return (name == other.name)? (value < other.value): (name < other.name);
+    bool operator <(const O0RequestParameter &other) const
+    {
+        return (name == other.name) ? (value < other.value) : (name < other.name);
     }
     QByteArray name;
     QByteArray value;
diff --git a/src/o0settingsstore.cpp b/src/o0settingsstore.cpp
index c475389..accba71 100644
--- a/src/o0settingsstore.cpp
+++ b/src/o0settingsstore.cpp
@@ -1,28 +1,33 @@
 #include <QCryptographicHash>
 #include <QByteArray>
 
-#include "o0settingsstore.h"
+#include "o2/o0settingsstore.h"
 
-static quint64 getHash(const QString &encryptionKey) {
+static quint64 getHash(const QString &encryptionKey)
+{
     return QCryptographicHash::hash(encryptionKey.toLatin1(), QCryptographicHash::Sha1).toULongLong();
 }
 
 O0SettingsStore::O0SettingsStore(const QString &encryptionKey, QObject *parent):
-    O0AbstractStore(parent), crypt_(getHash(encryptionKey)) {
+    O0AbstractStore(parent), crypt_(getHash(encryptionKey))
+{
     settings_ = new QSettings(this);
 }
 
 O0SettingsStore::O0SettingsStore(QSettings *settings, const QString &encryptionKey, QObject *parent):
-    O0AbstractStore(parent), crypt_(getHash(encryptionKey)) {
+    O0AbstractStore(parent), crypt_(getHash(encryptionKey))
+{
     settings_ = settings;
     settings_->setParent(this);
 }
 
-QString O0SettingsStore::groupKey() const {
+QString O0SettingsStore::groupKey() const
+{
     return groupKey_;
 }
 
-void O0SettingsStore::setGroupKey(const QString &groupKey) {
+void O0SettingsStore::setGroupKey(const QString &groupKey)
+{
     if (groupKey_ == groupKey) {
         return;
     }
@@ -30,7 +35,8 @@ void O0SettingsStore::setGroupKey(const QString &groupKey) {
     Q_EMIT groupKeyChanged();
 }
 
-QString O0SettingsStore::value(const QString &key, const QString &defaultValue) {
+QString O0SettingsStore::value(const QString &key, const QString &defaultValue)
+{
     QString fullKey = groupKey_.isEmpty() ? key : (groupKey_ + '/' + key);
     if (!settings_->contains(fullKey)) {
         return defaultValue;
@@ -38,7 +44,8 @@ QString O0SettingsStore::value(const QString &key, const QString &defaultValue)
     return crypt_.decryptToString(settings_->value(fullKey).toString());
 }
 
-void O0SettingsStore::setValue(const QString &key, const QString &value) {
+void O0SettingsStore::setValue(const QString &key, const QString &value)
+{
     QString fullKey = groupKey_.isEmpty() ? key : (groupKey_ + '/' + key);
     settings_->setValue(fullKey, crypt_.encryptToString(value));
 }
diff --git a/src/o0settingsstore.h b/src/o0settingsstore.h
index 2b6964a..4406503 100644
--- a/src/o0settingsstore.h
+++ b/src/o0settingsstore.h
@@ -4,11 +4,12 @@
 #include <QSettings>
 #include <QString>
 
-#include "o0abstractstore.h"
-#include "o0simplecrypt.h"
+#include "o2/o0abstractstore.h"
+#include "o2/o0simplecrypt.h"
 
 /// Persistent storage for authentication tokens, using QSettings.
-class O0SettingsStore: public O0AbstractStore {
+class O0SettingsStore: public O0AbstractStore
+{
     Q_OBJECT
 
 public:
@@ -34,7 +35,7 @@ Q_SIGNALS:
     void groupKeyChanged();
 
 protected:
-    QSettings* settings_;
+    QSettings *settings_;
     QString groupKey_;
     O0SimpleCrypt crypt_;
 };
diff --git a/src/o0simplecrypt.h b/src/o0simplecrypt.h
index 64f916d..b28c210 100644
--- a/src/o0simplecrypt.h
+++ b/src/o0simplecrypt.h
@@ -109,7 +109,10 @@ public:
     /**
       Returns true if SimpleCrypt has been initialized with a key.
       */
-    bool hasKey() const {return !m_keyParts.isEmpty();}
+    bool hasKey() const
+    {
+        return !m_keyParts.isEmpty();
+    }
 
     /**
       Sets the compression mode to use when encrypting data. The default mode is Auto.
@@ -117,11 +120,17 @@ public:
       Note that decryption is not influenced by this mode, as the decryption recognizes
       what mode was used when encrypting.
       */
-    void setCompressionMode(CompressionMode mode) {m_compressionMode = mode;}
+    void setCompressionMode(CompressionMode mode)
+    {
+        m_compressionMode = mode;
+    }
     /**
       Returns the CompressionMode that is currently in use.
       */
-    CompressionMode compressionMode() const {return m_compressionMode;}
+    CompressionMode compressionMode() const
+    {
+        return m_compressionMode;
+    }
 
     /**
       Sets the integrity mode to use when encrypting data. The default mode is Checksum.
@@ -129,23 +138,32 @@ public:
       Note that decryption is not influenced by this mode, as the decryption recognizes
       what mode was used when encrypting.
       */
-    void setIntegrityProtectionMode(IntegrityProtectionMode mode) {m_protectionMode = mode;}
+    void setIntegrityProtectionMode(IntegrityProtectionMode mode)
+    {
+        m_protectionMode = mode;
+    }
     /**
       Returns the IntegrityProtectionMode that is currently in use.
       */
-    IntegrityProtectionMode integrityProtectionMode() const {return m_protectionMode;}
+    IntegrityProtectionMode integrityProtectionMode() const
+    {
+        return m_protectionMode;
+    }
 
     /**
       Returns the last error that occurred.
       */
-    Error lastError() const {return m_lastError;}
+    Error lastError() const
+    {
+        return m_lastError;
+    }
 
     /**
       Encrypts the @arg plaintext string with the key the class was initialized with, and returns
       a cyphertext the result. The result is a base64 encoded version of the binary array that is the
       actual result of the string, so it can be stored easily in a text format.
       */
-    QString encryptToString(const QString& plaintext) ;
+    QString encryptToString(const QString &plaintext) ;
     /**
       Encrypts the @arg plaintext QByteArray with the key the class was initialized with, and returns
       a cyphertext the result. The result is a base64 encoded version of the binary array that is the
@@ -159,7 +177,7 @@ public:
       This method returns a byte array, that is useable for storing a binary format. If you need
       a string you can store in a text file, use encryptToString() instead.
       */
-    QByteArray encryptToByteArray(const QString& plaintext) ;
+    QByteArray encryptToByteArray(const QString &plaintext) ;
     /**
       Encrypts the @arg plaintext QByteArray with the key the class was initialized with, and returns
       a binary cyphertext in a QByteArray the result.
@@ -176,7 +194,7 @@ public:
       If an error occured, such as non-matching keys between encryption and decryption,
       an empty string or a string containing nonsense may be returned.
       */
-    QString decryptToString(const QString& cyphertext) ;
+    QString decryptToString(const QString &cyphertext) ;
     /**
       Decrypts a cyphertext string encrypted with this class with the set key back to the
       plain text version.
@@ -184,7 +202,7 @@ public:
       If an error occured, such as non-matching keys between encryption and decryption,
       an empty string or a string containing nonsense may be returned.
       */
-    QByteArray decryptToByteArray(const QString& cyphertext) ;
+    QByteArray decryptToByteArray(const QString &cyphertext) ;
     /**
       Decrypts a cyphertext binary encrypted with this class with the set key back to the
       plain text version.
@@ -204,11 +222,11 @@ public:
 
     //enum to describe options that have been used for the encryption. Currently only one, but
     //that only leaves room for future extensions like adding a cryptographic hash...
-    enum CryptoFlag{CryptoFlagNone = 0,
-                    CryptoFlagCompression = 0x01,
-                    CryptoFlagChecksum = 0x02,
-                    CryptoFlagHash = 0x04
-                   };
+    enum CryptoFlag {CryptoFlagNone = 0,
+                     CryptoFlagCompression = 0x01,
+                     CryptoFlagChecksum = 0x02,
+                     CryptoFlagHash = 0x04
+                    };
     Q_DECLARE_FLAGS(CryptoFlags, CryptoFlag)
 private:
 
diff --git a/src/o1.cpp b/src/o1.cpp
index 47783fc..67660fc 100644
--- a/src/o1.cpp
+++ b/src/o1.cpp
@@ -15,12 +15,13 @@
 #include <QMessageAuthenticationCode>
 #endif
 
-#include "o1.h"
-#include "o2replyserver.h"
-#include "o0globals.h"
-#include "o0settingsstore.h"
+#include "o2/o1.h"
+#include "o2/o2replyserver.h"
+#include "o2/o0globals.h"
+#include "o2/o0settingsstore.h"
 
-O1::O1(QObject *parent): O0BaseAuth(parent) {
+O1::O1(QObject *parent): O0BaseAuth(parent)
+{
     setSignatureMethod(O2_SIGNATURE_TYPE_HMAC_SHA1);
     manager_ = new QNetworkAccessManager(this);
     replyServer_ = new O2ReplyServer(this);
@@ -29,59 +30,72 @@ O1::O1(QObject *parent): O0BaseAuth(parent) {
     setCallbackUrl(O2_CALLBACK_URL);
 }
 
-QUrl O1::requestTokenUrl() {
+QUrl O1::requestTokenUrl()
+{
     return requestTokenUrl_;
 }
 
-void O1::setRequestTokenUrl(const QUrl &v) {
+void O1::setRequestTokenUrl(const QUrl &v)
+{
     requestTokenUrl_ = v;
     Q_EMIT requestTokenUrlChanged();
 }
 
-QList<O0RequestParameter> O1::requestParameters() {
+QList<O0RequestParameter> O1::requestParameters()
+{
     return requestParameters_;
 }
 
-void O1::setRequestParameters(const QList<O0RequestParameter> &v) {
+void O1::setRequestParameters(const QList<O0RequestParameter> &v)
+{
     requestParameters_ = v;
 }
 
-QString O1::callbackUrl() {
+QString O1::callbackUrl()
+{
     return callbackUrl_;
 }
 
-void O1::setCallbackUrl(const QString &v) {
+void O1::setCallbackUrl(const QString &v)
+{
     callbackUrl_ = v;
 }
 
-QUrl O1::authorizeUrl() {
+QUrl O1::authorizeUrl()
+{
     return authorizeUrl_;
 }
 
-void O1::setAuthorizeUrl(const QUrl &value) {
+void O1::setAuthorizeUrl(const QUrl &value)
+{
     authorizeUrl_ = value;
     Q_EMIT authorizeUrlChanged();
 }
 
-QUrl O1::accessTokenUrl() {
+QUrl O1::accessTokenUrl()
+{
     return accessTokenUrl_;
 }
 
-void O1::setAccessTokenUrl(const QUrl &value) {
+void O1::setAccessTokenUrl(const QUrl &value)
+{
     accessTokenUrl_ = value;
     Q_EMIT accessTokenUrlChanged();
 }
 
-QString O1::signatureMethod() {
+QString O1::signatureMethod()
+{
     return signatureMethod_;
 }
 
-void O1::setSignatureMethod(const QString &value) {
+void O1::setSignatureMethod(const QString &value)
+{
     qDebug() << "O1::setSignatureMethod: " << value;
     signatureMethod_ = value;
 }
 
-void O1::unlink() {
+void O1::unlink()
+{
     qDebug() << "O1::unlink";
     setLinked(false);
     setToken("");
@@ -94,7 +108,8 @@ void O1::unlink() {
 /// Calculate the HMAC variant of SHA1 hash.
 /// @author     http://qt-project.org/wiki/HMAC-SHA1.
 /// @copyright  Creative Commons Attribution-ShareAlike 2.5 Generic.
-static QByteArray hmacSha1(QByteArray key, QByteArray baseString) {
+static QByteArray hmacSha1(QByteArray key, QByteArray baseString)
+{
     int blockSize = 64;
     if (key.length() > blockSize) {
         key = QCryptographicHash::hash(key, QCryptographicHash::Sha1);
@@ -115,7 +130,8 @@ static QByteArray hmacSha1(QByteArray key, QByteArray baseString) {
 #endif
 
 /// Get HTTP operation name.
-static QString getOperationName(QNetworkAccessManager::Operation op) {
+static QString getOperationName(QNetworkAccessManager::Operation op)
+{
     switch (op) {
     case QNetworkAccessManager::GetOperation: return "GET";
     case QNetworkAccessManager::PostOperation: return "POST";
@@ -126,12 +142,14 @@ static QString getOperationName(QNetworkAccessManager::Operation op) {
 }
 
 /// Build a concatenated/percent-encoded string from a list of headers.
-QByteArray O1::encodeHeaders(const QList<O0RequestParameter> &headers) {
+QByteArray O1::encodeHeaders(const QList<O0RequestParameter> &headers)
+{
     return QUrl::toPercentEncoding(createQueryParameters(headers));
 }
 
 /// Build a base string for signing.
-QByteArray O1::getRequestBase(const QList<O0RequestParameter> &oauthParams, const QList<O0RequestParameter> &otherParams, const QUrl &url, QNetworkAccessManager::Operation op) {
+QByteArray O1::getRequestBase(const QList<O0RequestParameter> &oauthParams, const QList<O0RequestParameter> &otherParams, const QUrl &url, QNetworkAccessManager::Operation op)
+{
     QByteArray base;
 
     // Initialize base string with the operation name (e.g. "GET") and the base URL
@@ -147,7 +165,8 @@ QByteArray O1::getRequestBase(const QList<O0RequestParameter> &oauthParams, cons
     return base;
 }
 
-QByteArray O1::sign(const QList<O0RequestParameter> &oauthParams, const QList<O0RequestParameter> &otherParams, const QUrl &url, QNetworkAccessManager::Operation op, const QString &consumerSecret, const QString &tokenSecret) {
+QByteArray O1::sign(const QList<O0RequestParameter> &oauthParams, const QList<O0RequestParameter> &otherParams, const QUrl &url, QNetworkAccessManager::Operation op, const QString &consumerSecret, const QString &tokenSecret)
+{
     QByteArray baseString = getRequestBase(oauthParams, otherParams, url, op);
     QByteArray secret = QUrl::toPercentEncoding(consumerSecret) + "&" + QUrl::toPercentEncoding(tokenSecret);
 #if QT_VERSION >= 0x050100
@@ -157,7 +176,8 @@ QByteArray O1::sign(const QList<O0RequestParameter> &oauthParams, const QList<O0
 #endif
 }
 
-QByteArray O1::buildAuthorizationHeader(const QList<O0RequestParameter> &oauthParams) {
+QByteArray O1::buildAuthorizationHeader(const QList<O0RequestParameter> &oauthParams)
+{
     bool first = true;
     QByteArray ret("OAuth ");
     QList<O0RequestParameter> headers(oauthParams);
@@ -176,7 +196,8 @@ QByteArray O1::buildAuthorizationHeader(const QList<O0RequestParameter> &oauthPa
     return ret;
 }
 
-QByteArray O1::generateSignature(const QList<O0RequestParameter> headers, const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QNetworkAccessManager::Operation operation) {
+QByteArray O1::generateSignature(const QList<O0RequestParameter> headers, const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QNetworkAccessManager::Operation operation)
+{
     QByteArray signature;
     if (signatureMethod() == O2_SIGNATURE_TYPE_HMAC_SHA1) {
         signature = sign(headers, signingParameters, req.url(), operation, clientSecret(), tokenSecret());
@@ -186,7 +207,8 @@ QByteArray O1::generateSignature(const QList<O0RequestParameter> headers, const
     return signature;
 }
 
-void O1::link() {
+void O1::link()
+{
     qDebug() << "O1::link";
     if (linked()) {
         qDebug() << "O1::link: Linked already";
@@ -205,8 +227,9 @@ void O1::link() {
     // Get any query parameters for the request
     QUrlQuery requestData;
     O0RequestParameter param("", "");
-    foreach(param, requestParameters())
-      requestData.addQueryItem(QString(param.name), QUrl::toPercentEncoding(QString(param.value)));
+    foreach (param, requestParameters()) {
+        requestData.addQueryItem(QString(param.name), QUrl::toPercentEncoding(QString(param.value)));
+    }
 
     // Get the request url and add parameters
     QUrl requestUrl = requestTokenUrl();
@@ -237,13 +260,15 @@ void O1::link() {
     connect(reply, SIGNAL(finished()), this, SLOT(onTokenRequestFinished()));
 }
 
-void O1::onTokenRequestError(QNetworkReply::NetworkError error) {
+void O1::onTokenRequestError(QNetworkReply::NetworkError error)
+{
     QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
     qWarning() << "O1::onTokenRequestError:" << (int)error << reply->errorString() << reply->readAll();
     Q_EMIT linkingFailed();
 }
 
-void O1::onTokenRequestFinished() {
+void O1::onTokenRequestFinished()
+{
     qDebug() << "O1::onTokenRequestFinished";
     QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
     reply->deleteLater();
@@ -282,7 +307,8 @@ void O1::onTokenRequestFinished() {
     Q_EMIT openBrowser(url);
 }
 
-void O1::onVerificationReceived(QMap<QString, QString> params) {
+void O1::onVerificationReceived(QMap<QString, QString> params)
+{
     qDebug() << "O1::onVerificationReceived";
     Q_EMIT closeBrowser();
     verifier_ = params.value(O2_OAUTH_VERFIER, "");
@@ -295,7 +321,8 @@ void O1::onVerificationReceived(QMap<QString, QString> params) {
     }
 }
 
-void O1::exchangeToken() {
+void O1::exchangeToken()
+{
     qDebug() << "O1::exchangeToken";
 
     // Create token exchange request
@@ -318,13 +345,15 @@ void O1::exchangeToken() {
     connect(reply, SIGNAL(finished()), this, SLOT(onTokenExchangeFinished()));
 }
 
-void O1::onTokenExchangeError(QNetworkReply::NetworkError error) {
+void O1::onTokenExchangeError(QNetworkReply::NetworkError error)
+{
     QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
     qWarning() << "O1::onTokenExchangeError:" << (int)error << reply->errorString() << reply->readAll();
     Q_EMIT linkingFailed();
 }
 
-void O1::onTokenExchangeFinished() {
+void O1::onTokenExchangeFinished()
+{
     qDebug() << "O1::onTokenExchangeFinished";
 
     QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
@@ -344,7 +373,7 @@ void O1::onTokenExchangeFinished() {
         if (!response.isEmpty()) {
             QVariantMap extraTokens;
             foreach (QString key, response.keys()) {
-               extraTokens.insert(key, response.value(key));
+                extraTokens.insert(key, response.value(key));
             }
             setExtraTokens(extraTokens);
         }
@@ -356,7 +385,8 @@ void O1::onTokenExchangeFinished() {
     }
 }
 
-QMap<QString, QString> O1::parseResponse(const QByteArray &response) {
+QMap<QString, QString> O1::parseResponse(const QByteArray &response)
+{
     QMap<QString, QString> ret;
     foreach (QByteArray param, response.split('&')) {
         QList<QByteArray> kv = param.split('=');
@@ -367,7 +397,8 @@ QMap<QString, QString> O1::parseResponse(const QByteArray &response) {
     return ret;
 }
 
-QByteArray O1::nonce() {
+QByteArray O1::nonce()
+{
     static bool firstTime = true;
     if (firstTime) {
         firstTime = false;
diff --git a/src/o1.h b/src/o1.h
index 6d07b01..2330ca7 100644
--- a/src/o1.h
+++ b/src/o1.h
@@ -5,12 +5,13 @@
 #include <QUrl>
 #include <QNetworkReply>
 
-#include "o0baseauth.h"
+#include "o2/o0baseauth.h"
 
 class O2ReplyServer;
 
 /// Simple OAuth 1.0 authenticator.
-class O1: public O0BaseAuth {
+class O1: public O0BaseAuth
+{
     Q_OBJECT
 
 public:
@@ -92,7 +93,7 @@ Q_SIGNALS:
 
 protected Q_SLOTS:
     /// Handle verification received from the reply server.
-    virtual void onVerificationReceived(QMap<QString,QString> params);
+    virtual void onVerificationReceived(QMap<QString, QString> params);
 
     /// Handle token request error.
     virtual void onTokenRequestError(QNetworkReply::NetworkError error);
diff --git a/src/o1requestor.cpp b/src/o1requestor.cpp
index fabb4fa..f3e049a 100644
--- a/src/o1requestor.cpp
+++ b/src/o1requestor.cpp
@@ -3,41 +3,48 @@
 #include <QNetworkReply>
 #include <QNetworkAccessManager>
 
-#include "o1requestor.h"
-#include "o1timedreply.h"
-#include "o0globals.h"
+#include "o2/o1requestor.h"
+#include "o2/o1timedreply.h"
+#include "o2/o0globals.h"
 
-O1Requestor::O1Requestor(QNetworkAccessManager *manager, O1 *authenticator, QObject *parent): QObject(parent) {
+O1Requestor::O1Requestor(QNetworkAccessManager *manager, O1 *authenticator, QObject *parent): QObject(parent)
+{
     manager_ = manager;
     authenticator_ = authenticator;
 }
 
-QNetworkReply *O1Requestor::get(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters) {
+QNetworkReply *O1Requestor::get(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters)
+{
     QNetworkRequest request = setup(req, signingParameters, QNetworkAccessManager::GetOperation);
     return addTimer(manager_->get(request));
 }
 
-QNetworkReply *O1Requestor::post(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, const QByteArray &data) {
+QNetworkReply *O1Requestor::post(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, const QByteArray &data)
+{
     QNetworkRequest request = setup(req, signingParameters, QNetworkAccessManager::PostOperation);
     return addTimer(manager_->post(request, data));
 }
 
-QNetworkReply *O1Requestor::post(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QHttpMultiPart * multiPart) {
+QNetworkReply *O1Requestor::post(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QHttpMultiPart *multiPart)
+{
     QNetworkRequest request = setup(req, signingParameters, QNetworkAccessManager::PostOperation);
     return addTimer(manager_->post(request, multiPart));
 }
 
-QNetworkReply *O1Requestor::put(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, const QByteArray &data) {
+QNetworkReply *O1Requestor::put(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, const QByteArray &data)
+{
     QNetworkRequest request = setup(req, signingParameters, QNetworkAccessManager::PutOperation);
     return addTimer(manager_->put(request, data));
 }
 
-QNetworkReply *O1Requestor::addTimer(QNetworkReply *reply) {
+QNetworkReply *O1Requestor::addTimer(QNetworkReply *reply)
+{
     (void)new O1TimedReply(reply);
     return reply;
 }
 
-QNetworkRequest O1Requestor::setup(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QNetworkAccessManager::Operation operation) {
+QNetworkRequest O1Requestor::setup(const QNetworkRequest &req, const QList<O0RequestParameter> &signingParameters, QNetworkAccessManager::Operation operation)
+{
     // Collect OAuth parameters
     QList<O0RequestParameter> oauthParams;
     oauthParams.append(O0RequestParameter(O2_OAUTH_CONSUMER_KEY, authenticator_->clientId().toLatin1()));
diff --git a/src/o1requestor.h b/src/o1requestor.h
index 5de2fb2..0be21bc 100644
--- a/src/o1requestor.h
+++ b/src/o1requestor.h
@@ -5,14 +5,15 @@
 #include <QNetworkRequest>
 #include <QByteArray>
 
-#include "o1.h"
+#include "o2/o1.h"
 
 class QNetworkAccessManager;
 class QNetworkReply;
 class O1;
 
 /// Makes authenticated requests using OAuth 1.0.
-class O1Requestor: public QObject {
+class O1Requestor: public QObject
+{
     Q_OBJECT
 
 public:
@@ -57,5 +58,4 @@ protected:
     O1 *authenticator_;
 };
 
-
 #endif // O1REQUESTOR_H
diff --git a/src/o1timedreply.cpp b/src/o1timedreply.cpp
index 14897f5..4685be2 100644
--- a/src/o1timedreply.cpp
+++ b/src/o1timedreply.cpp
@@ -1,20 +1,23 @@
 #include <QTimer>
 #include <QNetworkReply>
 
-#include "o1timedreply.h"
+#include "o2/o1timedreply.h"
 
-O1TimedReply::O1TimedReply(QNetworkReply *parent, int pTimeout): QTimer(parent) {
+O1TimedReply::O1TimedReply(QNetworkReply *parent, int pTimeout): QTimer(parent)
+{
     setSingleShot(true);
     setInterval(pTimeout);
     connect(this, SIGNAL(timeout()), this, SLOT(onTimeout()));
     connect(parent, SIGNAL(finished()), this, SLOT(onFinished()));
 }
 
-void O1TimedReply::onFinished() {
+void O1TimedReply::onFinished()
+{
     stop();
     Q_EMIT finished();
 }
 
-void O1TimedReply::onTimeout() {
+void O1TimedReply::onTimeout()
+{
     Q_EMIT error(QNetworkReply::TimeoutError);
 }
diff --git a/src/o1timedreply.h b/src/o1timedreply.h
index 174cc0c..ddb4565 100644
--- a/src/o1timedreply.h
+++ b/src/o1timedreply.h
@@ -5,11 +5,12 @@
 #include <QTimer>
 
 /// A timer connected to a network reply.
-class O1TimedReply: public QTimer {
+class O1TimedReply: public QTimer
+{
     Q_OBJECT
 
 public:
-    explicit O1TimedReply(QNetworkReply *parent, int pTimeout=60*1000);
+    explicit O1TimedReply(QNetworkReply *parent, int pTimeout = 60 * 1000);
 
 Q_SIGNALS:
     /// Emitted when we have timed out waiting for the network reply.
diff --git a/src/o2.cpp b/src/o2.cpp
index e8108da..ec1799d 100644
--- a/src/o2.cpp
+++ b/src/o2.cpp
@@ -26,7 +26,8 @@
 #include "o0settingsstore.h"
 
 /// Parse JSON data into a QVariantMap
-static QVariantMap parseTokenResponse(const QByteArray &data) {
+static QVariantMap parseTokenResponse(const QByteArray &data)
+{
 #if QT_VERSION >= 0x050000
     QJsonParseError err;
     QJsonDocument doc = QJsonDocument::fromJson(data, &err);
@@ -57,7 +58,8 @@ static QVariantMap parseTokenResponse(const QByteArray &data) {
 }
 
 /// Add query parameters to a query
-static void addQueryParametersToUrl(QUrl &url,  QList<QPair<QString, QString> > parameters) {
+static void addQueryParametersToUrl(QUrl &url,  QList<QPair<QString, QString> > parameters)
+{
 #if QT_VERSION < 0x050000
     url.setQueryItems(parameters);
 #else
@@ -67,7 +69,8 @@ static void addQueryParametersToUrl(QUrl &url,  QList<QPair<QString, QString> >
 #endif
 }
 
-O2::O2(QObject *parent): O0BaseAuth(parent) {
+O2::O2(QObject *parent): O0BaseAuth(parent)
+{
     manager_ = new QNetworkAccessManager(this);
     replyServer_ = new O2ReplyServer(this);
     grantFlow_ = GrantFlowAuthorizationCode;
@@ -76,70 +79,85 @@ O2::O2(QObject *parent): O0BaseAuth(parent) {
     connect(replyServer_, SIGNAL(verificationReceived(QMap<QString,QString>)), this, SLOT(onVerificationReceived(QMap<QString,QString>)));
 }
 
-O2::GrantFlow O2::grantFlow() {
+O2::GrantFlow O2::grantFlow()
+{
     return grantFlow_;
 }
 
-void O2::setGrantFlow(O2::GrantFlow value) {
+void O2::setGrantFlow(O2::GrantFlow value)
+{
     grantFlow_ = value;
     Q_EMIT grantFlowChanged();
 }
 
-QString O2::username() {
+QString O2::username()
+{
     return username_;
 }
 
-void O2::setUsername(const QString &value) {
+void O2::setUsername(const QString &value)
+{
     username_ = value;
     Q_EMIT usernameChanged();
 }
 
-QString O2::password() {
+QString O2::password()
+{
     return password_;
 }
 
-void O2::setPassword(const QString &value) {
+void O2::setPassword(const QString &value)
+{
     password_ = value;
     Q_EMIT passwordChanged();
 }
 
-QString O2::scope() {
+QString O2::scope()
+{
     return scope_;
 }
 
-void O2::setScope(const QString &value) {
+void O2::setScope(const QString &value)
+{
     scope_ = value;
     Q_EMIT scopeChanged();
 }
 
-QString O2::requestUrl() {
+QString O2::requestUrl()
+{
     return requestUrl_.toString();
 }
 
-void O2::setRequestUrl(const QString &value) {
+void O2::setRequestUrl(const QString &value)
+{
     requestUrl_ = value;
     Q_EMIT requestUrlChanged();
 }
 
-QString O2::tokenUrl() {
+QString O2::tokenUrl()
+{
     return tokenUrl_.toString();
 }
 
-void O2::setTokenUrl(const QString &value) {
-    tokenUrl_= value;
+void O2::setTokenUrl(const QString &value)
+{
+    tokenUrl_ = value;
     Q_EMIT tokenUrlChanged();
 }
 
-QString O2::refreshTokenUrl() {
+QString O2::refreshTokenUrl()
+{
     return refreshTokenUrl_.toString();
 }
 
-void O2::setRefreshTokenUrl(const QString &value) {
+void O2::setRefreshTokenUrl(const QString &value)
+{
     refreshTokenUrl_ = value;
     Q_EMIT refreshTokenUrlChanged();
 }
 
-void O2::link() {
+void O2::link()
+{
     qDebug() << "O2::link";
 
     if (linked()) {
@@ -164,7 +182,7 @@ void O2::link() {
 
         // Assemble intial authentication URL
         QList<QPair<QString, QString> > parameters;
-        parameters.append(qMakePair(QString(O2_OAUTH2_RESPONSE_TYPE), (grantFlow_ == GrantFlowAuthorizationCode)? QString(O2_OAUTH2_GRANT_TYPE_CODE): QString(O2_OAUTH2_GRANT_TYPE_TOKEN)));
+        parameters.append(qMakePair(QString(O2_OAUTH2_RESPONSE_TYPE), (grantFlow_ == GrantFlowAuthorizationCode) ? QString(O2_OAUTH2_GRANT_TYPE_CODE) : QString(O2_OAUTH2_GRANT_TYPE_TOKEN)));
         parameters.append(qMakePair(QString(O2_OAUTH2_CLIENT_ID), clientId_));
         parameters.append(qMakePair(QString(O2_OAUTH2_REDIRECT_URI), redirectUri_));
         parameters.append(qMakePair(QString(O2_OAUTH2_SCOPE), scope_));
@@ -196,7 +214,8 @@ void O2::link() {
     }
 }
 
-void O2::unlink() {
+void O2::unlink()
+{
     qDebug() << "O2::unlink";
     setLinked(false);
     setToken(QString());
@@ -206,7 +225,8 @@ void O2::unlink() {
     Q_EMIT linkingSucceeded();
 }
 
-void O2::onVerificationReceived(const QMap<QString, QString> response) {
+void O2::onVerificationReceived(const QMap<QString, QString> response)
+{
     qDebug() << "O2::onVerificationReceived:" << response;
     qDebug() << "O2::onVerificationReceived: Emitting closeBrowser()";
     Q_EMIT closeBrowser();
@@ -223,8 +243,9 @@ void O2::onVerificationReceived(const QMap<QString, QString> response) {
 
         // Exchange access code for access/refresh tokens
         QString query;
-        if(!apiKey_.isEmpty())
+        if (!apiKey_.isEmpty()) {
             query = QString("?" + QString(O2_OAUTH2_API_KEY) + "=" + apiKey_);
+        }
         QNetworkRequest tokenRequest(QUrl(tokenUrl_.toString() + query));
         tokenRequest.setHeader(QNetworkRequest::ContentTypeHeader, O2_MIME_TYPE_XFORM);
         QMap<QString, QString> parameters;
@@ -244,17 +265,20 @@ void O2::onVerificationReceived(const QMap<QString, QString> response) {
     }
 }
 
-QString O2::code() {
+QString O2::code()
+{
     QString key = QString(O2_KEY_CODE).arg(clientId_);
     return store_->value(key);
 }
 
-void O2::setCode(const QString &c) {
+void O2::setCode(const QString &c)
+{
     QString key = QString(O2_KEY_CODE).arg(clientId_);
     store_->setValue(key, c);
 }
 
-void O2::onTokenReplyFinished() {
+void O2::onTokenReplyFinished()
+{
     qDebug() << "O2::onTokenReplyFinished";
     QNetworkReply *tokenReply = qobject_cast<QNetworkReply *>(sender());
     if (tokenReply->error() == QNetworkReply::NoError) {
@@ -283,7 +307,8 @@ void O2::onTokenReplyFinished() {
     tokenReply->deleteLater();
 }
 
-void O2::onTokenReplyError(QNetworkReply::NetworkError error) {
+void O2::onTokenReplyError(QNetworkReply::NetworkError error)
+{
     QNetworkReply *tokenReply = qobject_cast<QNetworkReply *>(sender());
     qWarning() << "O2::onTokenReplyError: " << error << ": " << tokenReply->errorString();
     qDebug() << "O2::onTokenReplyError: " << tokenReply->readAll();
@@ -293,7 +318,8 @@ void O2::onTokenReplyError(QNetworkReply::NetworkError error) {
     Q_EMIT linkingFailed();
 }
 
-QByteArray O2::buildRequestBody(const QMap<QString, QString> &parameters) {
+QByteArray O2::buildRequestBody(const QMap<QString, QString> &parameters)
+{
     QByteArray body;
     bool first = true;
     foreach (QString key, parameters.keys()) {
@@ -308,28 +334,33 @@ QByteArray O2::buildRequestBody(const QMap<QString, QString> &parameters) {
     return body;
 }
 
-int O2::expires() {
+int O2::expires()
+{
     QString key = QString(O2_KEY_EXPIRES).arg(clientId_);
     return store_->value(key).toInt();
 }
 
-void O2::setExpires(int v) {
+void O2::setExpires(int v)
+{
     QString key = QString(O2_KEY_EXPIRES).arg(clientId_);
     store_->setValue(key, QString::number(v));
 }
 
-QString O2::refreshToken() {
+QString O2::refreshToken()
+{
     QString key = QString(O2_KEY_REFRESH_TOKEN).arg(clientId_);
     return store_->value(key);
 }
 
-void O2::setRefreshToken(const QString &v) {
+void O2::setRefreshToken(const QString &v)
+{
     qDebug() << "O2::setRefreshToken" << v.left(4) << "...";
     QString key = QString(O2_KEY_REFRESH_TOKEN).arg(clientId_);
     store_->setValue(key, v);
 }
 
-void O2::refresh() {
+void O2::refresh()
+{
     qDebug() << "O2::refresh: Token: ..." << refreshToken().right(7);
 
     if (refreshToken().isEmpty()) {
@@ -358,7 +389,8 @@ void O2::refresh() {
     connect(refreshReply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onRefreshError(QNetworkReply::NetworkError)), Qt::QueuedConnection);
 }
 
-void O2::onRefreshFinished() {
+void O2::onRefreshFinished()
+{
     QNetworkReply *refreshReply = qobject_cast<QNetworkReply *>(sender());
     qDebug() << "O2::onRefreshFinished: Error" << (int)refreshReply->error() << refreshReply->errorString();
     if (refreshReply->error() == QNetworkReply::NoError) {
@@ -376,7 +408,8 @@ void O2::onRefreshFinished() {
     refreshReply->deleteLater();
 }
 
-void O2::onRefreshError(QNetworkReply::NetworkError error) {
+void O2::onRefreshError(QNetworkReply::NetworkError error)
+{
     QNetworkReply *refreshReply = qobject_cast<QNetworkReply *>(sender());
     qWarning() << "O2::onRefreshError: " << error;
     unlink();
@@ -384,34 +417,42 @@ void O2::onRefreshError(QNetworkReply::NetworkError error) {
     Q_EMIT refreshFinished(error);
 }
 
-QString O2::localhostPolicy() const {
+QString O2::localhostPolicy() const
+{
     return localhostPolicy_;
 }
 
-void O2::setLocalhostPolicy(const QString &value) {
+void O2::setLocalhostPolicy(const QString &value)
+{
     localhostPolicy_ = value;
 }
 
-QString O2::apiKey() {
+QString O2::apiKey()
+{
     return apiKey_;
 }
 
-void O2::setApiKey(const QString &value) {
+void O2::setApiKey(const QString &value)
+{
     apiKey_ = value;
 }
 
-QByteArray O2::replyContent() {
+QByteArray O2::replyContent()
+{
     return replyServer_->replyContent();
 }
 
-void O2::setReplyContent(const QByteArray &value) {
+void O2::setReplyContent(const QByteArray &value)
+{
     replyServer_->setReplyContent(value);
 }
 
-bool O2::ignoreSslErrors() {
+bool O2::ignoreSslErrors()
+{
     return timedReplies_.ignoreSslErrors();
 }
 
-void O2::setIgnoreSslErrors(bool ignoreSslErrors) {
+void O2::setIgnoreSslErrors(bool ignoreSslErrors)
+{
     timedReplies_.setIgnoreSslErrors(ignoreSslErrors);
 }
diff --git a/src/o2.h b/src/o2.h
index 250ea50..3f7591b 100644
--- a/src/o2.h
+++ b/src/o2.h
@@ -13,7 +13,8 @@
 class O2ReplyServer;
 
 /// Simple OAuth2 authenticator.
-class O2: public O0BaseAuth {
+class O2: public O0BaseAuth
+{
     Q_OBJECT
     Q_ENUMS(GrantFlow)
 
diff --git a/src/o2reply.cpp b/src/o2reply.cpp
index 4e03172..db8517a 100644
--- a/src/o2reply.cpp
+++ b/src/o2reply.cpp
@@ -1,36 +1,43 @@
 #include <QTimer>
 #include <QNetworkReply>
 
-#include "o2reply.h"
+#include "o2/o2reply.h"
 
-O2Reply::O2Reply(QNetworkReply *r, int timeOut, QObject *parent): QTimer(parent), reply(r) {
+O2Reply::O2Reply(QNetworkReply *r, int timeOut, QObject *parent): QTimer(parent), reply(r)
+{
     setSingleShot(true);
     connect(this, SIGNAL(error(QNetworkReply::NetworkError)), reply, SIGNAL(error(QNetworkReply::NetworkError)), Qt::QueuedConnection);
     connect(this, SIGNAL(timeout()), this, SLOT(onTimeOut()), Qt::QueuedConnection);
     start(timeOut);
 }
 
-void O2Reply::onTimeOut() {
+void O2Reply::onTimeOut()
+{
     Q_EMIT error(QNetworkReply::TimeoutError);
 }
 
-O2ReplyList::~O2ReplyList() {
+O2ReplyList::~O2ReplyList()
+{
     foreach (O2Reply *timedReply, replies_) {
         delete timedReply;
     }
 }
 
-void O2ReplyList::add(QNetworkReply *reply) {
-    if (reply && ignoreSslErrors())
-            reply->ignoreSslErrors();
+void O2ReplyList::add(QNetworkReply *reply)
+{
+    if (reply && ignoreSslErrors()) {
+        reply->ignoreSslErrors();
+    }
     add(new O2Reply(reply));
 }
 
-void O2ReplyList::add(O2Reply *reply) {
+void O2ReplyList::add(O2Reply *reply)
+{
     replies_.append(reply);
 }
 
-void O2ReplyList::remove(QNetworkReply *reply) {
+void O2ReplyList::remove(QNetworkReply *reply)
+{
     O2Reply *o2Reply = find(reply);
     if (o2Reply) {
         o2Reply->stop();
@@ -38,7 +45,8 @@ void O2ReplyList::remove(QNetworkReply *reply) {
     }
 }
 
-O2Reply *O2ReplyList::find(QNetworkReply *reply) {
+O2Reply *O2ReplyList::find(QNetworkReply *reply)
+{
     foreach (O2Reply *timedReply, replies_) {
         if (timedReply->reply == reply) {
             return timedReply;
diff --git a/src/o2reply.h b/src/o2reply.h
index 15f1571..4bfcd51 100644
--- a/src/o2reply.h
+++ b/src/o2reply.h
@@ -9,7 +9,8 @@
 #include <QByteArray>
 
 /// A network request/reply pair that can time out.
-class O2Reply: public QTimer {
+class O2Reply: public QTimer
+{
     Q_OBJECT
 
 public:
@@ -27,9 +28,13 @@ public:
 };
 
 /// List of O2Replies.
-class O2ReplyList {
+class O2ReplyList
+{
 public:
-    O2ReplyList() { ignoreSslErrors_ = false; }
+    O2ReplyList()
+    {
+        ignoreSslErrors_ = false;
+    }
 
     /// Destructor.
     /// Deletes all O2Reply instances in the list.
diff --git a/src/o2replyserver.cpp b/src/o2replyserver.cpp
index 00dad96..b4c5da7 100644
--- a/src/o2replyserver.cpp
+++ b/src/o2replyserver.cpp
@@ -11,20 +11,23 @@
 #include <QUrlQuery>
 #endif
 
-#include "o2replyserver.h"
+#include "o2/o2replyserver.h"
 
-O2ReplyServer::O2ReplyServer(QObject *parent): QTcpServer(parent) {
+O2ReplyServer::O2ReplyServer(QObject *parent): QTcpServer(parent)
+{
     connect(this, SIGNAL(newConnection()), this, SLOT(onIncomingConnection()));
     replyContent_ = "<HTML></HTML>";
 }
 
-void O2ReplyServer::onIncomingConnection() {
+void O2ReplyServer::onIncomingConnection()
+{
     QTcpSocket *socket = nextPendingConnection();
     connect(socket, SIGNAL(readyRead()), this, SLOT(onBytesReady()), Qt::UniqueConnection);
     connect(socket, SIGNAL(disconnected()), socket, SLOT(deleteLater()));
 }
 
-void O2ReplyServer::onBytesReady() {
+void O2ReplyServer::onBytesReady()
+{
     qDebug() << "O2ReplyServer::onBytesReady";
     QTcpSocket *socket = qobject_cast<QTcpSocket *>(sender());
     if (!socket) {
@@ -44,7 +47,8 @@ void O2ReplyServer::onBytesReady() {
     Q_EMIT verificationReceived(queryParams);
 }
 
-QMap<QString, QString> O2ReplyServer::parseQueryParams(QByteArray *data) {
+QMap<QString, QString> O2ReplyServer::parseQueryParams(QByteArray *data)
+{
     qDebug() << "O2ReplyServer::parseQueryParams";
 
     QString splitGetLine = QString(*data).split("\r\n").first();
@@ -72,10 +76,12 @@ QMap<QString, QString> O2ReplyServer::parseQueryParams(QByteArray *data) {
     return queryParams;
 }
 
-QByteArray O2ReplyServer::replyContent() {
+QByteArray O2ReplyServer::replyContent()
+{
     return replyContent_;
 }
 
-void O2ReplyServer::setReplyContent(const QByteArray &value) {
+void O2ReplyServer::setReplyContent(const QByteArray &value)
+{
     replyContent_ = value;
 }
diff --git a/src/o2replyserver.h b/src/o2replyserver.h
index 5a9d2f2..f464126 100644
--- a/src/o2replyserver.h
+++ b/src/o2replyserver.h
@@ -7,7 +7,8 @@
 #include <QString>
 
 /// HTTP server to process authentication response.
-class O2ReplyServer: public QTcpServer {
+class O2ReplyServer: public QTcpServer
+{
     Q_OBJECT
 
 public:
diff --git a/src/o2requestor.cpp b/src/o2requestor.cpp
index d737d35..89248a5 100644
--- a/src/o2requestor.cpp
+++ b/src/o2requestor.cpp
@@ -4,11 +4,12 @@
 #include <QUrlQuery>
 #endif
 
-#include "o2requestor.h"
-#include "o2.h"
-#include "o0globals.h"
+#include "o2/o2requestor.h"
+#include "o2/o2.h"
+#include "o2/o0globals.h"
 
-O2Requestor::O2Requestor(QNetworkAccessManager *manager, O2 *authenticator, QObject *parent): QObject(parent), reply_(NULL), status_(Idle) {
+O2Requestor::O2Requestor(QNetworkAccessManager *manager, O2 *authenticator, QObject *parent): QObject(parent), reply_(NULL), status_(Idle)
+{
     manager_ = manager;
     authenticator_ = authenticator;
     if (authenticator) {
@@ -18,10 +19,12 @@ O2Requestor::O2Requestor(QNetworkAccessManager *manager, O2 *authenticator, QObj
     connect(authenticator, SIGNAL(refreshFinished(QNetworkReply::NetworkError)), this, SLOT(onRefreshFinished(QNetworkReply::NetworkError)), Qt::QueuedConnection);
 }
 
-O2Requestor::~O2Requestor() {
+O2Requestor::~O2Requestor()
+{
 }
 
-int O2Requestor::get(const QNetworkRequest &req) {
+int O2Requestor::get(const QNetworkRequest &req)
+{
     if (-1 == setup(req, QNetworkAccessManager::GetOperation)) {
         return -1;
     }
@@ -32,7 +35,8 @@ int O2Requestor::get(const QNetworkRequest &req) {
     return id_;
 }
 
-int O2Requestor::post(const QNetworkRequest &req, const QByteArray &data) {
+int O2Requestor::post(const QNetworkRequest &req, const QByteArray &data)
+{
     if (-1 == setup(req, QNetworkAccessManager::PostOperation)) {
         return -1;
     }
@@ -45,7 +49,8 @@ int O2Requestor::post(const QNetworkRequest &req, const QByteArray &data) {
     return id_;
 }
 
-int O2Requestor::put(const QNetworkRequest &req, const QByteArray &data) {
+int O2Requestor::put(const QNetworkRequest &req, const QByteArray &data)
+{
     if (-1 == setup(req, QNetworkAccessManager::PutOperation)) {
         return -1;
     }
@@ -58,7 +63,8 @@ int O2Requestor::put(const QNetworkRequest &req, const QByteArray &data) {
     return id_;
 }
 
-void O2Requestor::onRefreshFinished(QNetworkReply::NetworkError error) {
+void O2Requestor::onRefreshFinished(QNetworkReply::NetworkError error)
+{
     if (status_ != Requesting) {
         qWarning() << "O2Requestor::onRefreshFinished: No pending request";
         return;
@@ -71,7 +77,8 @@ void O2Requestor::onRefreshFinished(QNetworkReply::NetworkError error) {
     }
 }
 
-void O2Requestor::onRequestFinished() {
+void O2Requestor::onRequestFinished()
+{
     QNetworkReply *senderReply = qobject_cast<QNetworkReply *>(sender());
     QNetworkReply::NetworkError error = senderReply->error();
     if (status_ == Idle) {
@@ -85,7 +92,8 @@ void O2Requestor::onRequestFinished() {
     }
 }
 
-void O2Requestor::onRequestError(QNetworkReply::NetworkError error) {
+void O2Requestor::onRequestError(QNetworkReply::NetworkError error)
+{
     qWarning() << "O2Requestor::onRequestError: Error" << (int)error;
     if (status_ == Idle) {
         return;
@@ -107,7 +115,8 @@ void O2Requestor::onRequestError(QNetworkReply::NetworkError error) {
     QTimer::singleShot(10, this, SLOT(finish()));
 }
 
-void O2Requestor::onUploadProgress(qint64 uploaded, qint64 total) {
+void O2Requestor::onUploadProgress(qint64 uploaded, qint64 total)
+{
     if (status_ == Idle) {
         qWarning() << "O2Requestor::onUploadProgress: No pending request";
         return;
@@ -118,7 +127,8 @@ void O2Requestor::onUploadProgress(qint64 uploaded, qint64 total) {
     Q_EMIT uploadProgress(id_, uploaded, total);
 }
 
-int O2Requestor::setup(const QNetworkRequest &req, QNetworkAccessManager::Operation operation) {
+int O2Requestor::setup(const QNetworkRequest &req, QNetworkAccessManager::Operation operation)
+{
     static int currentId;
     QUrl url;
 
@@ -144,7 +154,8 @@ int O2Requestor::setup(const QNetworkRequest &req, QNetworkAccessManager::Operat
     return id_;
 }
 
-void O2Requestor::finish() {
+void O2Requestor::finish()
+{
     QByteArray data;
     if (status_ == Idle) {
         qWarning() << "O2Requestor::finish: No pending request";
@@ -158,7 +169,8 @@ void O2Requestor::finish() {
     Q_EMIT finished(id_, error_, data);
 }
 
-void O2Requestor::retry() {
+void O2Requestor::retry()
+{
     if (status_ != Requesting) {
         qWarning() << "O2Requestor::retry: No pending request";
         return;
diff --git a/src/o2requestor.h b/src/o2requestor.h
index 939e598..fef7fc0 100644
--- a/src/o2requestor.h
+++ b/src/o2requestor.h
@@ -8,12 +8,13 @@
 #include <QUrl>
 #include <QByteArray>
 
-#include "o2reply.h"
+#include "o2/o2reply.h"
 
 class O2;
 
 /// Makes authenticated requests.
-class O2Requestor: public QObject {
+class O2Requestor: public QObject
+{
     Q_OBJECT
 
 public:
diff --git a/src/o2simplecrypt.cpp b/src/o2simplecrypt.cpp
index 210ae12..4a8584c 100644
--- a/src/o2simplecrypt.cpp
+++ b/src/o2simplecrypt.cpp
@@ -24,7 +24,7 @@ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "o0simplecrypt.h"
+#include "o2/o0simplecrypt.h"
 #include <QByteArray>
  @@ -61,16 +61,17 @@ void O0SimpleCrypt::splitKey()
 {
     m_keyParts.clear();
     m_keyParts.resize(8);
-    for (int i=0;i<8;i++) {
+    for (int i = 0; i < 8; i++) {
         quint64 part = m_key;
-        for (int j=i; j>0; j--)
+        for (int j = i; j > 0; j--) {
             part = part >> 8;
+        }
         part = part & 0xff;
         m_keyParts[i] = static_cast<char>(part);
     }
 }
 
-QByteArray O0SimpleCrypt::encryptToByteArray(const QString& plaintext)
+QByteArray O0SimpleCrypt::encryptToByteArray(const QString &plaintext)
 {
     QByteArray plaintextArray = plaintext.toUtf8();
     return encryptToByteArray(plaintextArray);
@@ -84,7 +85,6 @@ QByteArray O0SimpleCrypt::encryptToByteArray(QByteArray plaintext)
         return QByteArray();
     }
 
-
     QByteArray ba = plaintext;
 
     CryptoFlags flags = CryptoFlagNone;
@@ -136,7 +136,7 @@ QByteArray O0SimpleCrypt::encryptToByteArray(QByteArray plaintext)
     return resultArray;
 }
 
-QString O0SimpleCrypt::encryptToString(const QString& plaintext)
+QString O0SimpleCrypt::encryptToString(const QString &plaintext)
 {
     QByteArray plaintextArray = plaintext.toUtf8();
     QByteArray cypher = encryptToByteArray(plaintextArray);
@@ -168,7 +168,7 @@ QString O0SimpleCrypt::decryptToString(QByteArray cypher)
     return plaintext;
 }
 
-QByteArray O0SimpleCrypt::decryptToByteArray(const QString& cyphertext)
+QByteArray O0SimpleCrypt::decryptToByteArray(const QString &cyphertext)
 {
     QByteArray cyphertextArray = QByteArray::fromBase64(cyphertext.toLatin1());
     QByteArray ba = decryptToByteArray(cyphertextArray);
@@ -193,7 +193,7 @@ QByteArray O0SimpleCrypt::decryptToByteArray(QByteArray cypher)
 
     char version = ba.at(0);
 
-    if (version !=3) {  //we only work with version 3
+    if (version != 3) { //we only work with version 3
         m_lastError = ErrorUnknownVersion;
         qWarning() << "Invalid version or not a cyphertext.";
         return QByteArray();
@@ -246,8 +246,9 @@ QByteArray O0SimpleCrypt::decryptToByteArray(QByteArray cypher)
         return QByteArray();
     }
 
-    if (flags.testFlag(CryptoFlagCompression))
+    if (flags.testFlag(CryptoFlagCompression)) {
         ba = qUncompress(ba);
+    }
 
     m_lastError = ErrorNoError;
     return ba;
